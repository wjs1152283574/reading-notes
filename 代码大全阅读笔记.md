### 代码大全笔记

* 第一章
    1. 什么是软件创建（即一个新项目该如何着手）
        - 定义问题（项目定义）
        - 需求分析（项目功能起草）
        - 实现计划（技术/架构选型）
        - 总体设计（架构设计/服务划分等）
        - 详细设计（往下设计每个环节即每个服务实现）
        - 创建即实现（创建活动/编程实现，占项目30%～80%时间）
        - 系统集成
        - 单元测试
        - 系统测试（测试环境打通流程）
        - 校正性维护（运行维护）
        - 功能强化（项目后期新增需求）

    ##### 单元小结
    - 创建活动是总体设计和系统测试之间承上启下的工作
    - 创建活动主要包括：详细设计/编码/调试和单元测试
    - 关于创建活动的其它称谓：实现/编程等
    - 创建活动质量对软件质量有潜在影响
---

* 第二章
    1. 隐喻理解软件创建

    ##### 单元小结

    - 隐喻通过把软件开发与你熟知的事物联系在一起，从而使你对其有更深刻的理解
    - 一些隐喻要好于其他隐喻（更好的隐喻能跟好的解释实际现象）
    - 把软件创建与建造建筑类比，表明开发软件前要精心准备，并表明了大规模想摸与小规模项目之间的差别
    - 认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的，为每件工作选择合适的工具，是优秀程序员的首要素质之一
---

* 第三章
    1. 创建活动（编码）前的先决条件的重要性论据
    - 优秀程序员的一个突出特点是他们采用高质量的过程来创建软件。这种过程在计划的开始、 中间和末尾都强调高质量。
    ```
    如果你只在一个计划即将结束时强调质量，那你注重的只是测试。
    当某些人一谈起软件质 量时，他们首先想到的便是测试。 然而，事实上测试只是全部质量控制策略的一部分。
    而且并 不是最重要的部分。 测试既不能消除在正确方向上的错误工作，
    也不能消除在错误方向上的正 确工作的错误，这种错误必须在测试开始之前就清除掉，
    甚至在创建工作开始之前就要努力清 除掉它们。
    ```

    2. 造成准备不足的原因
    - 一些程序员并不作准备工作，因为他们抵制不了立刻开始进行编码工作的渴望。 如果你就是这种程序员，那我对你有两条忠告。 第一，阅读一下下一部分工作的内容提示，或许你会从 中发现一些你没想到的问题。 第二，要注意自己的问题。 只要创建过几个大的程序，你就会明白强调准备工作的必要性。 不要忘记自己的经验教训。
    - 深刻理解软件开发顺序流程，解释并坚持做准备工作

    3. 问题定义先决条件
    - 定义问题，简短描述。
    ```
    问题定义只描述要解决的问题是什么，根本不涉及解决方法。 它应该是一个简短的说明， 听起来像一个问题。 比如“我们无法跟上指令系统”听起来像一个问题，也是一个好的问题定义。 而“我们需要优化数据入口系统以便跟上指令系统”则是一个糟糕的问题定义，它听起来不像是个问题而更像是个解决方案。
    ```

    4. 需求分析先决条件
    - 为什么要有正式的需求
    ```
    明确的需求是很重要的，因为： 明确的需求可以保证是由用户而不是程序员决定系统的功能。 
    如果需求是很清楚的，那么 用户可以对其进行评定，并确认自己是否同意。 
    如果需求不很清楚，那么程序员在编程过程中 就不得不自己决定系统功能，明确的需求防止对用户需求进行猜测。 
    明确的需求也可以避免引起争议。 在开始编程之前，系统的范围已经明确确定了。 
    如果在 编程过程中，两个程序员对系统干什么有争议，那么只要查阅一下写好的需求分析，问题就解决了
    ```
    - 在创建阶段如何应对需求变化    
        - 用章节后面的检查表来评估你的需求分析质量
        - 让每个人都知道由于变化需求所付出的代价（人力/时间；即所有人都应该为自己的修改建议负责，可根据自己经验来设计成本最低的办法）
        - 建立一套更改控制过程(解释如下)
        - ```
        如果雇员们坚持更改的热情高涨，则可以考虑建立一个审查这种更改建议的正式委员会。 
        用户改变主意，意识到他们的软件需要更强的功能是非常正常的。 
        但如果他们频繁地改变主意 以至于你无法跟上他们的速度，那就不正常了。 
        这时如果拥有一套控制更改的正式过程，那将 使大家都会感到宽慰。 
        你感到宽慰是因为现在你只在特定的时候处理变动问题。 
        顾客也感到宽 慰是因为有专门机构处理他们的意见，会使他们感到自己倍受重视。
            ```
        - 用开发的方法来容纳变动
        - ```
            一些开发方法可以极大地扩展你应付变更需求的能力。 
            原型化开发的方法可能帮助你在 全力以赴投入工作以前，首先了解系统的需求。 
            渐进开发的方法是指按阶段公布系统。 每次你 只做一点儿，从用户那里得到一些反馈后，
            你再做一些调整的改动，然后再增加一些内容。 
            这 种方法的关键是使用短周期开发方法，以便你对顾客的需求变更迅速作出反应。
            ```
        - 放弃项目
        - ```
            如果需求特别稀奇古怪或者反复无常，上面那些办法全都不起作用，那就放弃这个项目。 即使你并不能真正地砍掉这个项目，你也可以考虑一下这样做会怎么样。 考虑在你砍掉这个项 目之前，事情会发展到什么地步。 假如在某一情况下，的确可以把这个项目扔进垃圾箱，那么 还可以考虑一下有或没有这个项目会造成什么区别。
            ```
        - 基本参照列表
        - ```
            需求内容: 
            系统的所有输入都定义了吗？包括它们的来源、 精度、 取值范围和频率？ 
            系统所有的输出都定义了吗？包括它们的目标、 精度、 取值范围、 频率和格式？ 
            所有的报告格式都定义了吗？ 
            所有的硬件与软件接口都定义了吗？ 
            所有的通信界面都定义了吗？包括握手、 错误检查以及通信约定？ 
            是否从用户的观点出发，定义了所有必要操作的反应时间？ 
            是否定义了时间问题，如处理时间、 数据传输率以及系统吞吐能力？ 
            是否对用户所要求完成的任务都作出了规定？ 
            每项任务所需用到和产生的数据都规定了吗？ 
            规定保密级别了吗？ 
            规定可靠性了吗？包括软件出错的后果、 在出错时要保护的至关重要的信息、 以及错误 测试和恢复策略。 
            规定所需最大内存了吗？ 
            所需最大存储容量规定了吗？ 
            对系统的维护性是否作出了规定？包括系统对运行环境、 精度、 性能以其与其它软件的 接口等方面变化的适应能力规定了吗？ 
            是否规定了相互冲突的设计之间的折衷原则，例如，在坚固性与准确性之间如何进行折衷？ 
            是否制定了系统成败的标准？ 
            关于需求的完善性:
            在开发开始前暂时得不到的信息是什么？
            是否规定了不够完善的区域？ 
            需求定义是否已经完善到了可以成为软件标准的地步？ 
            需求中是否有哪一部分令你感到不安？有没有根本不可能实现，而仅仅为了取悦老板和 用户才加进来的内容？ 
            关于需求的质量:
            需求是否是用用户的语言制定的？用户也这样认为吗？ 
            需求中是否每一条之间都尽量避免冲突？ 
            需求中是否注意了避免规定设计工作？ 
            需求在详细程度方面是否保持了一致性；有没有应该更详细些的需求？有没有应该更 简略些的？ 
            需求是否明确得可以分为一些独立的可执行部分，而每一部分又都很明了？ 
            是否每一条都与问题和答案相关？是否每一条都可以追溯到产生它的环境中？ 
            是否每一条需求都可以作为测试依据？
            是否可以针对每一条进行独立测试以确定是否满足需求？ 
            是否对可能的改动作出了规定？包括每一改动的可能性？

            关于需求定义的进一步阅读 以下是一些给出了如何进行需求定义的书： DeMarco, Tom 《 Structured Analysis and Systems Specification ： Tools and Techniques 》
            ```

    5. 结构设计先决条件
    - 结构设计检查表
    ```
    一个好的结构设计应该阐明所有问题。 这个表并不是用于指导结构设计的，而只是想提供 一种方法，通过它，
    你可以估计处于软件食物链顶层的程序员可以从食物中获得多少营养。 它 可以作为建立自己的检查表的起点。 
    同需求定义检查表的使用一样，如果你正在从事一个非正 式的项目，那么其中有些条款是不必考虑的。 
    但如果你正在开发一个较大的系统，那绝大部分 内容都是非常有用的。

    软件的总体组织形式是否清晰明了？包括对于结构设计的总体评论与描述。 
    模块定义是否清楚？包括它们的功能及其与其它模块的接口。
    需求定义中所提出的所有功能，是否有恰当数量的模块覆盖？ 
    结构设计是否考虑了可能的更改？ 
    是否包括了必要的购买？ 
    是否阐明了如何改进重新启用的代码来满足现在的结构设计需求？ 
    是否描述并验证了所有主要的数据结构？ 
    主要数据结构是否隐含在存取子程序中？ 
    规定数据库组织形式和其它内容了吗？ 
    是否说明并验证所有关键算法？ 
    是否说明验证所有主要目标？ 
    说明处理用户输入的策略了吗？ 
    说明并验证处理输入／输出的策略了吗？ 
    是否定义了用户界面的关键方面？ 
    用户界面是否进行了模块化，以使对它所作的改动不会影响程序其它部分 ? 
    是否描述并验证了内存使用估算和内存管理？ 
    是否对每一模块给出了存储空间和速度限制？ 
    是否说明了字符串处理策略？
    是否提供了对字符串占用空间的估计？ 
    所提供的错误处理策略是不是一致的？ 
    是否对错误信息进行了成套化管理以提供一个整洁的用户界面？ 
    是否指定了坚固性级别？ 
    有没有哪一部分结构设计被过分定义或缺少定义了？它是否明确说明了 ? 
    是否明确提出了系统目标？ 
    整个结构在概念上是否是一致的？ 
    机器和使用实现的语言是否顶层设计依赖？ 
    给出做出每个重要决定的动机了吗？ 
    你作为系统实现者的程序员，对结构设计满意吗？
    ```

    - 选择语言先决条件
    ```
    需要了解选项语言的特性，结合项目定义/需求定义等先决条件来选择语言
    同时也需要考虑人力资源，即目前程序员熟悉语言即采用新语言学习成本等问题
    程序员采用自己熟悉的语言进行编码的效率远高于使用新学习的语言
    ```
    - 编程约定
    ```
    在高质量软件中，你可以发现结构设计的概念完整性与较低层次实现之间的密切联系。 
    这种联系必须与指导它的结构设计保持一致，而且，这种一致应该是内在的。 
    这就是实现时在给 变量和子程序命名、 进行格式约定和注释约定时的指导方针。 
    在复杂的软件中，结构设计指导方针对程序进行结构性平衡，而实现指导方式则在较低层 次上实现程序的和谐统一，
    使得每一个子程序都成为总体设计的一个可以信赖的组成部分。 任何一个大的软件系统都需要结构控制，以便把编程语言的细节统一到一起。 
    大型系统的完美之 处便是它的每一个细节都体现了它的结构设计风格。 
    如果没有一个统一约束，那么你的软件只 能是一个由各种风格不同的子程序拼凑到一起的拼盘而已。 
    即使你有一个关于一幅画的美妙总体构思，但如果其中一部分是用古典手法的，另一部分 是印象派的，其余则是超现实主义风格的，那么，再美妙的构思又有什么用呢？不论其中每一 部分是如何密切联系主题的，这幅画的概念完整性都将荡然无存。 
    同样，程序也需要较低层次 上的完整性。 在创建工作开始之前，一定要写明你将要采用的编程约定、约定说明一定要写得非常详尽， 
    使得在编程过程中无法对其进行改动。 本书提供了许多非常详细的约定。
    ```

    - 应花在先决条件上的时间
    ```
    用于问题定义、 需求分析和软件结构设计的时间，随项目需要的不同而不同。 
    一般来说， 一个运行良好的项目通常把 20 ～ 30 ％的时间用于先决条件。
    这 20 ～ 30 ％的时间中不包括进行详 细设计的时间，因为它是创建活动的一部分。

    只有在先决条件讨论完毕之后，才能知道要做的是什么东西，才能预估工期即所需资源等。
    接到一个新项目在没有完成先决条件时所给出的工期一般都会有比较大的出入。
    即先决条件准备及讨论也需要作为一个被重视的环节并给予充足时间。
    ```

    - 改变先决条件以适应你的项目
    ```
    先决条件随项目规模和正式性不同而变化。 
    本章指出了大规模和小型项目之间先决条件的 判别，可以根据项目的特点对先决条件作出合适的调整。 
    要想详细了解大项目与小项目之间的 不同，请参看第 21 章“程序规模是如何影响创建活动的。
    ```

    ##### 单元小结
    - 如果箱开发一个高质量的软件，必须自始至终重视质量问题，在开始阶段强调质量往往比在最后强调质量更有效。
    - 程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。
    - 如果问题定义工作做得不好，那么在创建阶段，所解决的问题可能并不是用户真正要解决的问题。
    - 如果需求分析工作做得不好，很可能因此而漏掉要解决问题中的重要细节。 
    在创建工 作后更改需求，要比在需求分析阶段进行更改的成本高 20 到 100 倍。 
    所以，在开始编程前一定要确认需求定义工作一切正常。
    - 在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。
    - 在创建活动开始之前如果无法完成准备工作，可以尝试在不太稳固的基础上进行创建活动。
---

* 第四章
    1. 子程序建立检查表
    ```
        是否检查过先决条件已经满足了？ 
        定义子程序将要解决的问题了吗？ 
        结构设计是否足够清楚，使得你可以给子程序起个好名字？ 
        考虑过如何测试子程序了吗？ 
        是否从模块化水平或者满足时间和内存需求角度考虑过效率问题？ 
        是否查阅过参考书；以寻找有帮助的算法？ 
        是否用详尽的 PDL 设计子程序？ 
        在必要时，是否在逻辑设计步骤前考虑了数据？(这点很重要，因为高并发处理与普通数据量的处理很不一样) 
        是否检查过 PDL ， 它很容易理解吗？ 
        是否注意到了足以使你返回到结构设计阶段的警告（使用了全局数据，更适合其它子 程序的操作，等等）。 
        是否使用了 PDL 到代码流程，是否把 PDL 作为编码基础并把原有的 PDL 转为注释？ 
        是否精确地把 PDL 翻译成了代码？ 
        在作出假设时，验证它们了吗？ 
        是从几个设计方案中选择了最好的，还是随意选择了一个方案？
    ``` 
    ##### 单元小结
    - 要想写好 PDL ， 首先要用易懂的自然语言，避免拘泥于某种程序语言，其次要在意向层次上写 PDL ， 描述设计作什么而不是如何作。
    - PDL 到代码流程方法是详细设计的有力工具，而且使得编码非常容易。可以把PDL直接翻译成注释，但要注意保证注释是精确而有用的。
    - 应该在工作的每一步中都检查子程序，并鼓励同事们检查。 这样，可以在投入的资金和工作努力最少时便发现错误，从而极大降低改错成本。
---

* 第五章
    1. 什么是子程序
    ```
        在讨论高质量子程序的细节问题之前，我们首先来考虑两个基本名词。
        什么叫“子程序”？ 子程序是具有单一功能的可调用的函数或过程。 
        比如 C 中的函数， Pascal 或 Ada 中的函数或过 程， Basic 中的子程序或 Fortran 中的子程序。 
        有时， C 中的宏指令或者 Basic 中用 GOSUB 调用的代码块也可认为是子程序。 
        在生成上述函数或过程中，都可以使用创建高质量子程序所使用 的技术。
    ```
    2. 生成子程序的原因
        - 降低复杂性，子程序制作一件事，调用者无需关心实现细节，可扩展性，可维护性
        - 限制了改动带来的影响
        - 隐含顺序，即调用顺序可灵活修改以满足业务
        - 改进性能，对于子程序的优化即可提升所有调用该子程序的程序性能
        - 进行集中控制
        - 隐含数据结构
        - 隐含全局变量
        - 隐含指针操作
        - 重新使用代码段
        - 计划开发一个程序族
        ```
            如果想改进一个程序，最好把将要改动的那部分放进子程序中，将 其独立。 
            这样，就可以改动这个子程序而不致影响程序的其余部分，或者干脆用一个全新的子 程序代替它。 
            几年前，我曾经负责一个替保险推销员编写系列软件的小组，
            我们不得不根据每 一个推销员的保险率、 报价单格式等等来完成一个特定的程序。 
            但这些程序的绝大部分又都是 相同的：输入潜在客户的子程序，客户数据库中存储的信息、 查看、 计算价格等等。 
            这个小组 对程序进行了模块化，这样，随推销员而变化的部分都放在自己的模块中。 
            最初的程序可能要 用三个月的时间来开发，但是，在此之后，每来一个推销员，我们只改写其中屈指可数的几个 模块就可以了。 
            两三天就可能写完一个要求的程序，这简直是一种享受！
        ```
        - 提高部分代码的可读性，在调用时仅仅需要添加上简单注释加上子程序语意化的命名即可
        - 分隔复杂操作
        - 独立非标准语言函数的调用
        ```
            绝大多数实现语言都含有一些非标准的但却方便的扩展。 
            使用这种扩展的影响是两面性的，因为在另外一个环境下它可能无法使用。 
            这个运行环境的差异可能是由于硬件不同、 语言的生产商不同、 或者虽然生产商相同、 但版本不同而产生的。 
            如果使用了某种扩展，可以建立一个作为进入这种扩展大门的子程序。 
            然后，在需要时，可以用订做的扩展来代替这一非标准扩展。
        ```
        - 是出于模块化的考虑吗？
        ```
            绝不是。 有了这么些代码放入子程序的理由，这个理由是不必要的。
            事实上，有些工作更适合放在一个大的子程序中完成（关于程序最佳长度的讨论见 5.5 节“子程序长度”）。
        ```
    3. 子程序恰当命名（子程序目的越单一命名越容易且准确）
        - 对于过程的命名，可以用一个比较强的动词带目标的形式: `PrintReport() ， Checkotderlnfo()`
        - 对于函数名，可以使用返回值的描述：`Cos() ， PrinterReady() ， CurrentPenColor() `
        - 避免无意义或模棱两可的动词如：`HandleCalculation() ， ProcessInput()`
        - 描述子程序所做的一切
        ```
            在子程序名字中，应描述所有输出结果及其附加结果。 
            如果一个子程序用于计算报告总数，并设置一个全局变量来表示所有的数据都已准备好了，正等待打印， 
            那么， ComputeReportTotal() 就不是一个充分的名字了。 而ComputeReportTotalAndSetPrintingReadyVar() 又是一个太长而且太愚蠢的命名。 如果子程序带有附加结果， 那必然会产生许多又长又臭的名字。 解决的办法不应该是使用描述不足名字，而是采用直接实 现每件事的原则来编程，从而避免程序带有附加结果。
        ```
        - 名字的长度要符合需要
        ```
            研究表明，变量名称的最佳长度是 9 到 15 个字母，子程序往往比 变量要复杂，因而其名字也要长些。 
            南安普敦大学的 MichaelRees 认为恰当的长度是 20 到 35 个字母。 但是，一般来说 15 到 20 个字母可能更现实一些，不过有些名称可能有时要比它长。
        ```
        - 建立用于通用操作的约定
        ```
            在某些系统中，区分各种不同的操作是非常重要的。 而命名约定可能是区分这些操作最简单也是最可靠的方法。 
            比如，在开发 0S/2 显示管理程序时，如果子 程序是关于直接输入的，就在其名称前面加一个“ Get ”前缀，
            如果是非直接输入的则加“ Query 前缀，这样，返回当前输入字符的 GetlnputChar() 将清除输入缓冲区。
            而同样是返回当前输入 字符的 QuerylnPutChar() 则不清除缓冲区。
        ```
    4. 强内聚性
        - 描述
        ```
            内聚性指的是在一个子程序中，各种操作之间互相联系的紧密程度。
            有些程序员喜欢用“强 度”一词来代替内聚性，在一个子程序中各种操作之间的联系程度有多强？一个诸如 Sin() 之类的函数内聚性是很强的，因为整个子程序所从事的工作都是围绕一个函数的。 
            而像 SinAndTan() 的内聚程度就要低得多了，因为子程序中所进行的是一项以上的工作。
            强调强相关性的目的是， 每一个子程序只需作好一项工作，而不必过分考虑其它任务。 
            这样作的好处是可以提高可靠性。 通过对 450 个 Fortran 子程序的调查表明， 50％的强内聚性子程序是没有错误的，
            而只有 18 ％的弱内聚性子程序才是无错的 (Card,Carch 和 Agresti 1986) 。 
            另一项对另外 450 个子程序的调查则表明，弱内聚性子程序的出错机会要比强内聚性出错机会 高 6 倍，
            而修正成本则要高 19 倍（ Selby 和 Basili 1991 ）。 关于内聚性的讨论一般是指几个层次。 
            理解概念要比单纯记住名词重要得多。 可以利用这 些概念来生成内聚性尽可能强的子程序。  
        ```
        


