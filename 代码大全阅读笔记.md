### 代码大全笔记

* 第一章
    1. 什么是软件创建（即一个新项目该如何着手）
        - 定义问题（项目定义）
        - 需求分析（项目功能起草）
        - 实现计划（技术/架构选型,这里应该包括基本的服务模版/编码约束等，防止出现风格迥异的服务）
        - 总体设计（架构设计/服务划分等）
        - 详细设计（往下设计每个环节即每个服务实现）
        - 创建即实现（创建活动/编程实现，占项目30%～80%时间）
        - 系统集成
        - 单元测试
        - 系统测试（测试环境打通流程）
        - 校正性维护（运行维护）
        - 功能强化（项目后期新增需求）

    ##### 单元小结
    - 创建活动是总体设计和系统测试之间承上启下的工作
    - 创建活动主要包括：详细设计/编码/调试和单元测试
    - 关于创建活动的其它称谓：实现/编程等
    - 创建活动质量对软件质量有潜在影响
---

* 第二章
    1. 隐喻理解软件创建

    ##### 单元小结

    - 隐喻通过把软件开发与你熟知的事物联系在一起，从而使你对其有更深刻的理解
    - 一些隐喻要好于其他隐喻（更好的隐喻能跟好的解释实际现象）
    - 把软件创建与建造建筑类比，表明开发软件前要精心准备，并表明了大规模想摸与小规模项目之间的差别
    - 认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的，为每件工作选择合适的工具，是优秀程序员的首要素质之一
---

* 第三章
    1. 创建活动（编码）前的先决条件的重要性论据
    - 优秀程序员的一个突出特点是他们采用高质量的过程来创建软件。这种过程在计划的开始、 中间和末尾都强调高质量。
    ```
    如果你只在一个计划即将结束时强调质量，那你注重的只是测试。
    当某些人一谈起软件质 量时，他们首先想到的便是测试。 然而，事实上测试只是全部质量控制策略的一部分。
    而且并 不是最重要的部分。 测试既不能消除在正确方向上的错误工作，
    也不能消除在错误方向上的正 确工作的错误，这种错误必须在测试开始之前就清除掉，
    甚至在创建工作开始之前就要努力清 除掉它们。
    ```

    2. 造成准备不足的原因
    - 一些程序员并不作准备工作，因为他们抵制不了立刻开始进行编码工作的渴望。 如果你就是这种程序员，那我对你有两条忠告。 第一，阅读一下下一部分工作的内容提示，或许你会从 中发现一些你没想到的问题。 第二，要注意自己的问题。 只要创建过几个大的程序，你就会明白强调准备工作的必要性。 不要忘记自己的经验教训。
    - 深刻理解软件开发顺序流程，解释并坚持做准备工作

    3. 问题定义先决条件
    - 定义问题，简短描述。
    ```
    问题定义只描述要解决的问题是什么，根本不涉及解决方法。 它应该是一个简短的说明， 听起来像一个问题。 比如“我们无法跟上指令系统”听起来像一个问题，也是一个好的问题定义。 而“我们需要优化数据入口系统以便跟上指令系统”则是一个糟糕的问题定义，它听起来不像是个问题而更像是个解决方案。
    ```

    4. 需求分析先决条件
    - 为什么要有正式的需求
    ```
    明确的需求是很重要的，因为： 明确的需求可以保证是由用户而不是程序员决定系统的功能。 
    如果需求是很清楚的，那么 用户可以对其进行评定，并确认自己是否同意。 
    如果需求不很清楚，那么程序员在编程过程中 就不得不自己决定系统功能，明确的需求防止对用户需求进行猜测。 
    明确的需求也可以避免引起争议。 在开始编程之前，系统的范围已经明确确定了。 
    如果在 编程过程中，两个程序员对系统干什么有争议，那么只要查阅一下写好的需求分析，问题就解决了
    ```
    - 在创建阶段如何应对需求变化    
        - 用章节后面的检查表来评估你的需求分析质量
        - 让每个人都知道由于变化需求所付出的代价（人力/时间；即所有人都应该为自己的修改建议负责，可根据自己经验来设计成本最低的办法）
        - 建立一套更改控制过程(解释如下)
        - ```
        如果雇员们坚持更改的热情高涨，则可以考虑建立一个审查这种更改建议的正式委员会。 
        用户改变主意，意识到他们的软件需要更强的功能是非常正常的。 
        但如果他们频繁地改变主意 以至于你无法跟上他们的速度，那就不正常了。 
        这时如果拥有一套控制更改的正式过程，那将 使大家都会感到宽慰。 
        你感到宽慰是因为现在你只在特定的时候处理变动问题。 
        顾客也感到宽 慰是因为有专门机构处理他们的意见，会使他们感到自己倍受重视。
            ```
        - 用开发的方法来容纳变动
        - ```
            一些开发方法可以极大地扩展你应付变更需求的能力。 
            原型化开发的方法可能帮助你在 全力以赴投入工作以前，首先了解系统的需求。 
            渐进开发的方法是指按阶段公布系统。 每次你 只做一点儿，从用户那里得到一些反馈后，
            你再做一些调整的改动，然后再增加一些内容。 
            这 种方法的关键是使用短周期开发方法，以便你对顾客的需求变更迅速作出反应。
            ```
        - 放弃项目
        - ```
            如果需求特别稀奇古怪或者反复无常，上面那些办法全都不起作用，那就放弃这个项目。 即使你并不能真正地砍掉这个项目，你也可以考虑一下这样做会怎么样。 考虑在你砍掉这个项 目之前，事情会发展到什么地步。 假如在某一情况下，的确可以把这个项目扔进垃圾箱，那么 还可以考虑一下有或没有这个项目会造成什么区别。
            ```
        - 基本参照列表
        - ```
            需求内容: 
            系统的所有输入都定义了吗？包括它们的来源、 精度、 取值范围和频率？ 
            系统所有的输出都定义了吗？包括它们的目标、 精度、 取值范围、 频率和格式？ 
            所有的报告格式都定义了吗？ 
            所有的硬件与软件接口都定义了吗？ 
            所有的通信界面都定义了吗？包括握手、 错误检查以及通信约定？ 
            是否从用户的观点出发，定义了所有必要操作的反应时间？ 
            是否定义了时间问题，如处理时间、 数据传输率以及系统吞吐能力？ 
            是否对用户所要求完成的任务都作出了规定？ 
            每项任务所需用到和产生的数据都规定了吗？ 
            规定保密级别了吗？ 
            规定可靠性了吗？包括软件出错的后果、 在出错时要保护的至关重要的信息、 以及错误 测试和恢复策略。 
            规定所需最大内存了吗？ 
            所需最大存储容量规定了吗？ 
            对系统的维护性是否作出了规定？包括系统对运行环境、 精度、 性能以其与其它软件的 接口等方面变化的适应能力规定了吗？ 
            是否规定了相互冲突的设计之间的折衷原则，例如，在坚固性与准确性之间如何进行折衷？ 
            是否制定了系统成败的标准？ 
            关于需求的完善性:
            在开发开始前暂时得不到的信息是什么？
            是否规定了不够完善的区域？ 
            需求定义是否已经完善到了可以成为软件标准的地步？ 
            需求中是否有哪一部分令你感到不安？有没有根本不可能实现，而仅仅为了取悦老板和 用户才加进来的内容？ 
            关于需求的质量:
            需求是否是用用户的语言制定的？用户也这样认为吗？ 
            需求中是否每一条之间都尽量避免冲突？ 
            需求中是否注意了避免规定设计工作？ 
            需求在详细程度方面是否保持了一致性；有没有应该更详细些的需求？有没有应该更 简略些的？ 
            需求是否明确得可以分为一些独立的可执行部分，而每一部分又都很明了？ 
            是否每一条都与问题和答案相关？是否每一条都可以追溯到产生它的环境中？ 
            是否每一条需求都可以作为测试依据？
            是否可以针对每一条进行独立测试以确定是否满足需求？ 
            是否对可能的改动作出了规定？包括每一改动的可能性？

            关于需求定义的进一步阅读 以下是一些给出了如何进行需求定义的书： DeMarco, Tom 《 Structured Analysis and Systems Specification ： Tools and Techniques 》
            ```

    5. 结构设计先决条件
    - 结构设计检查表
    ```
    一个好的结构设计应该阐明所有问题。 这个表并不是用于指导结构设计的，而只是想提供 一种方法，通过它，
    你可以估计处于软件食物链顶层的程序员可以从食物中获得多少营养。 它 可以作为建立自己的检查表的起点。 
    同需求定义检查表的使用一样，如果你正在从事一个非正 式的项目，那么其中有些条款是不必考虑的。 
    但如果你正在开发一个较大的系统，那绝大部分 内容都是非常有用的。

    软件的总体组织形式是否清晰明了？包括对于结构设计的总体评论与描述。 
    模块定义是否清楚？包括它们的功能及其与其它模块的接口。
    需求定义中所提出的所有功能，是否有恰当数量的模块覆盖？ 
    结构设计是否考虑了可能的更改？ 
    是否包括了必要的购买？ 
    是否阐明了如何改进重新启用的代码来满足现在的结构设计需求？ 
    是否描述并验证了所有主要的数据结构？ 
    主要数据结构是否隐含在存取子程序中？ 
    规定数据库组织形式和其它内容了吗？ 
    是否说明并验证所有关键算法？ 
    是否说明验证所有主要目标？ 
    说明处理用户输入的策略了吗？ 
    说明并验证处理输入／输出的策略了吗？ 
    是否定义了用户界面的关键方面？ 
    用户界面是否进行了模块化，以使对它所作的改动不会影响程序其它部分 ? 
    是否描述并验证了内存使用估算和内存管理？ 
    是否对每一模块给出了存储空间和速度限制？ 
    是否说明了字符串处理策略？
    是否提供了对字符串占用空间的估计？ 
    所提供的错误处理策略是不是一致的？ 
    是否对错误信息进行了成套化管理以提供一个整洁的用户界面？ 
    是否指定了坚固性级别？ 
    有没有哪一部分结构设计被过分定义或缺少定义了？它是否明确说明了 ? 
    是否明确提出了系统目标？ 
    整个结构在概念上是否是一致的？ 
    机器和使用实现的语言是否顶层设计依赖？ 
    给出做出每个重要决定的动机了吗？ 
    你作为系统实现者的程序员，对结构设计满意吗？
    ```

    - 选择语言先决条件
    ```
    需要了解选项语言的特性，结合项目定义/需求定义等先决条件来选择语言
    同时也需要考虑人力资源，即目前程序员熟悉语言即采用新语言学习成本等问题
    程序员采用自己熟悉的语言进行编码的效率远高于使用新学习的语言
    ```
    - 编程约定
    ```
    在高质量软件中，你可以发现结构设计的概念完整性与较低层次实现之间的密切联系。 
    这种联系必须与指导它的结构设计保持一致，而且，这种一致应该是内在的。 
    这就是实现时在给 变量和子程序命名、 进行格式约定和注释约定时的指导方针。 
    在复杂的软件中，结构设计指导方针对程序进行结构性平衡，而实现指导方式则在较低层 次上实现程序的和谐统一，
    使得每一个子程序都成为总体设计的一个可以信赖的组成部分。 任何一个大的软件系统都需要结构控制，以便把编程语言的细节统一到一起。 
    大型系统的完美之 处便是它的每一个细节都体现了它的结构设计风格。 
    如果没有一个统一约束，那么你的软件只 能是一个由各种风格不同的子程序拼凑到一起的拼盘而已。 
    即使你有一个关于一幅画的美妙总体构思，但如果其中一部分是用古典手法的，另一部分 是印象派的，其余则是超现实主义风格的，那么，再美妙的构思又有什么用呢？不论其中每一 部分是如何密切联系主题的，这幅画的概念完整性都将荡然无存。 
    同样，程序也需要较低层次 上的完整性。 在创建工作开始之前，一定要写明你将要采用的编程约定、约定说明一定要写得非常详尽， 
    使得在编程过程中无法对其进行改动。 本书提供了许多非常详细的约定。
    ```

    - 应花在先决条件上的时间
    ```
    用于问题定义、 需求分析和软件结构设计的时间，随项目需要的不同而不同。 
    一般来说， 一个运行良好的项目通常把 20 ～ 30 ％的时间用于先决条件。
    这 20 ～ 30 ％的时间中不包括进行详 细设计的时间，因为它是创建活动的一部分。

    只有在先决条件讨论完毕之后，才能知道要做的是什么东西，才能预估工期即所需资源等。
    接到一个新项目在没有完成先决条件时所给出的工期一般都会有比较大的出入。
    即先决条件准备及讨论也需要作为一个被重视的环节并给予充足时间。
    ```

    - 改变先决条件以适应你的项目
    ```
    先决条件随项目规模和正式性不同而变化。 
    本章指出了大规模和小型项目之间先决条件的 判别，可以根据项目的特点对先决条件作出合适的调整。 
    要想详细了解大项目与小项目之间的 不同，请参看第 21 章“程序规模是如何影响创建活动的。
    ```

    ##### 单元小结
    - 如果箱开发一个高质量的软件，必须自始至终重视质量问题，在开始阶段强调质量往往比在最后强调质量更有效。
    - 程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。
    - 如果问题定义工作做得不好，那么在创建阶段，所解决的问题可能并不是用户真正要解决的问题。
    - 如果需求分析工作做得不好，很可能因此而漏掉要解决问题中的重要细节。 
    在创建工 作后更改需求，要比在需求分析阶段进行更改的成本高 20 到 100 倍。 
    所以，在开始编程前一定要确认需求定义工作一切正常。
    - 在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。
    - 在创建活动开始之前如果无法完成准备工作，可以尝试在不太稳固的基础上进行创建活动。
---

* 第四章
    1. 子程序建立检查表
    ```
        是否检查过先决条件已经满足了？ 
        定义子程序将要解决的问题了吗？ 
        结构设计是否足够清楚，使得你可以给子程序起个好名字？ 
        考虑过如何测试子程序了吗？ 
        是否从模块化水平或者满足时间和内存需求角度考虑过效率问题？ 
        是否查阅过参考书；以寻找有帮助的算法？ 
        是否用详尽的 PDL 设计子程序？ 
        在必要时，是否在逻辑设计步骤前考虑了数据？(这点很重要，因为高并发处理与普通数据量的处理很不一样) 
        是否检查过 PDL ， 它很容易理解吗？ 
        是否注意到了足以使你返回到结构设计阶段的警告（使用了全局数据，更适合其它子 程序的操作，等等）。 
        是否使用了 PDL 到代码流程，是否把 PDL 作为编码基础并把原有的 PDL 转为注释？ 
        是否精确地把 PDL 翻译成了代码？ 
        在作出假设时，验证它们了吗？ 
        是从几个设计方案中选择了最好的，还是随意选择了一个方案？
    ``` 
    ##### 单元小结
    - 要想写好 PDL ， 首先要用易懂的自然语言，避免拘泥于某种程序语言，其次要在意向层次上写 PDL ， 描述设计作什么而不是如何作。
    - PDL 到代码流程方法是详细设计的有力工具，而且使得编码非常容易。可以把PDL直接翻译成注释，但要注意保证注释是精确而有用的。
    - 应该在工作的每一步中都检查子程序，并鼓励同事们检查。 这样，可以在投入的资金和工作努力最少时便发现错误，从而极大降低改错成本。
---

* 第五章
    1. 什么是子程序
    ```
        在讨论高质量子程序的细节问题之前，我们首先来考虑两个基本名词。
        什么叫“子程序”？ 子程序是具有单一功能的可调用的函数或过程。 
        比如 C 中的函数， Pascal 或 Ada 中的函数或过 程， Basic 中的子程序或 Fortran 中的子程序。 
        有时， C 中的宏指令或者 Basic 中用 GOSUB 调用的代码块也可认为是子程序。 
        在生成上述函数或过程中，都可以使用创建高质量子程序所使用 的技术。
    ```
    2. 生成子程序的原因
        - 降低复杂性，子程序制作一件事，调用者无需关心实现细节，可扩展性，可维护性
        - 限制了改动带来的影响
        - 隐含顺序，即调用顺序可灵活修改以满足业务
        - 改进性能，对于子程序的优化即可提升所有调用该子程序的程序性能
        - 进行集中控制
        - 隐含数据结构
        - 隐含全局变量
        - 隐含指针操作
        - 重新使用代码段
        - 计划开发一个程序族
        ```
            如果想改进一个程序，最好把将要改动的那部分放进子程序中，将 其独立。 
            这样，就可以改动这个子程序而不致影响程序的其余部分，或者干脆用一个全新的子 程序代替它。 
            几年前，我曾经负责一个替保险推销员编写系列软件的小组，
            我们不得不根据每 一个推销员的保险率、 报价单格式等等来完成一个特定的程序。 
            但这些程序的绝大部分又都是 相同的：输入潜在客户的子程序，客户数据库中存储的信息、 查看、 计算价格等等。 
            这个小组 对程序进行了模块化，这样，随推销员而变化的部分都放在自己的模块中。 
            最初的程序可能要 用三个月的时间来开发，但是，在此之后，每来一个推销员，我们只改写其中屈指可数的几个 模块就可以了。 
            两三天就可能写完一个要求的程序，这简直是一种享受！
        ```
        - 提高部分代码的可读性，在调用时仅仅需要添加上简单注释加上子程序语意化的命名即可
        - 分隔复杂操作
        - 独立非标准语言函数的调用
        ```
            绝大多数实现语言都含有一些非标准的但却方便的扩展。 
            使用这种扩展的影响是两面性的，因为在另外一个环境下它可能无法使用。 
            这个运行环境的差异可能是由于硬件不同、 语言的生产商不同、 或者虽然生产商相同、 但版本不同而产生的。 
            如果使用了某种扩展，可以建立一个作为进入这种扩展大门的子程序。 
            然后，在需要时，可以用订做的扩展来代替这一非标准扩展。
        ```
        - 是出于模块化的考虑吗？
        ```
            绝不是。 有了这么些代码放入子程序的理由，这个理由是不必要的。
            事实上，有些工作更适合放在一个大的子程序中完成（关于程序最佳长度的讨论见 5.5 节“子程序长度”）。
        ```
    3. 子程序恰当命名（子程序目的越单一命名越容易且准确）
        - 对于过程的命名，可以用一个比较强的动词带目标的形式: `PrintReport() ， Checkotderlnfo()`
        - 对于函数名，可以使用返回值的描述：`Cos() ， PrinterReady() ， CurrentPenColor() `
        - 避免无意义或模棱两可的动词如：`HandleCalculation() ， ProcessInput()`
        - 描述子程序所做的一切
        ```
            在子程序名字中，应描述所有输出结果及其附加结果。 
            如果一个子程序用于计算报告总数，并设置一个全局变量来表示所有的数据都已准备好了，正等待打印， 
            那么， ComputeReportTotal() 就不是一个充分的名字了。 而ComputeReportTotalAndSetPrintingReadyVar() 又是一个太长而且太愚蠢的命名。 如果子程序带有附加结果， 那必然会产生许多又长又臭的名字。 解决的办法不应该是使用描述不足名字，而是采用直接实 现每件事的原则来编程，从而避免程序带有附加结果。
        ```
        - 名字的长度要符合需要
        ```
            研究表明，变量名称的最佳长度是 9 到 15 个字母，子程序往往比 变量要复杂，因而其名字也要长些。 
            南安普敦大学的 MichaelRees 认为恰当的长度是 20 到 35 个字母。 但是，一般来说 15 到 20 个字母可能更现实一些，不过有些名称可能有时要比它长。
        ```
        - 建立用于通用操作的约定
        ```
            在某些系统中，区分各种不同的操作是非常重要的。 而命名约定可能是区分这些操作最简单也是最可靠的方法。 
            比如，在开发 0S/2 显示管理程序时，如果子 程序是关于直接输入的，就在其名称前面加一个“ Get ”前缀，
            如果是非直接输入的则加“ Query 前缀，这样，返回当前输入字符的 GetlnputChar() 将清除输入缓冲区。
            而同样是返回当前输入 字符的 QuerylnPutChar() 则不清除缓冲区。
        ```
    4. 强内聚性
        - 描述
        ```
            内聚性指的是在一个子程序中，各种操作之间互相联系的紧密程度。
            有些程序员喜欢用“强度”一词来代替内聚性，在一个子程序中各种操作之间的联系程度有多强？一个诸如 Sin() 之类的函数内聚性是很强的，因为整个子程序所从事的工作都是围绕一个函数的。 
            而像 SinAndTan() 的内聚程度就要低得多了，因为子程序中所进行的是一项以上的工作。
            强调强相关性的目的是， 每一个子程序只需作好一项工作，而不必过分考虑其它任务。 
            这样作的好处是可以提高可靠性。 通过对 450 个 Fortran 子程序的调查表明， 50％的强内聚性子程序是没有错误的，
            而只有 18 ％的弱内聚性子程序才是无错的 (Card,Carch 和 Agresti 1986) 。 
            另一项对另外 450 个子程序的调查则表明，弱内聚性子程序的出错机会要比强内聚性出错机会 高 6 倍，
            而修正成本则要高 19 倍（ Selby 和 Basili 1991 ）。 关于内聚性的讨论一般是指几个层次。 
            理解概念要比单纯记住名词重要得多。 可以利用这 些概念来生成内聚性尽可能强的子程序。  
        ```
        - 功能内聚性。功能内聚性是最强也是最好的一种内聚，当程序执行一项并且仅仅是一项工作时，就是这种内聚性。
        - 顺序内聚性
        ```
            顺序内聚性是指在子程序内包含需要按特定顺序进行的、 逐步分享数据而又 不形成一个完整功能的操作，
            假设一个子程序包括五个操作：打开文件、 读文件、 进行两个计 算、 输出结果、 关闭文件。 
            如果这些操作是由两个子程序完成的， DoStep1() 打开文件、 读文件 和计算操作，
            而 DoStep2()则进行输出结果和关闭文件操作。 这两个子程序都具有顺序内聚性。 
            因为用这种方式把操作分隔开来，并没有产生出独立的功能。
        ```
        - 通讯内聚性。通讯内聚性是在一个子程序中，两个操作只是使用相同数据，而不存在其它 任何联系时产生的。
        - 临时内聚性。
        ```
            因为同时执行的原因才被放入同一个子程序里，这时产生临时内聚性。 
            典型的例子有； Startup() ， CompleteNewEmployee() ， Shutdown() 等等，
            有些程序员认为临时内聚性是不可接受的，因为它们有时与拙劣的编程联系在一切，比如，
            在像 Startup() 这类子程序中往往含 有东拼西凑的杂烩般的代码。 
            要避免这个问题，可以把临时内聚性子程序设计成一系列工作的组织者。 
            前述的 Startup () 子程序进行的操作可能包括：读取一个配置文件、初始化一个临时文件、建立内存管理、显示 初始化屏幕。 
            要想使它最有效地完成这些任务，可以让这个子程序去调用其它的专门功能的子 程序，而不是由它自己直接来完成这些任务。
        ```
        - 不可取的内聚性
        ```
            其余类型的内聚性，一般来说都是不可取的。 其后果往往是产生一些组织混乱而又难以调 试和改进的代码。 
            如果一个子程序具有不良的内聚性，那最好重新创建一个较好的子程序，而 不要去试图修补它。 
            知道应该避免什么是非常重要的，以下就是一些不可取的内聚性：
            1. 过程内聚性
            当子程序中的操作是按某一特定顺序进行的，就是过程内聚性。 
            与顺序内聚性不同，过程内聚性中的顺序操作使用的并不是相同数据。 
            比如，如果用户想按一定的顺序打 印报告，而所拥有的子程序是用于打印销售收入、 开支、 雇员电话表的。 
            那给这个子程序命名 是非常困难的，而模棱两可的名字往往代表着某种警告。
            2. 逻辑内聚性
            子程序不应该有类似布尔值这样的入参，而应该拆分为不同子程序只做一件事情，升级为功能内聚性
            3. 偶然内聚性
            当同一个子程序中的操作之间无任何联系时，为偶然内聚性。 也叫作“无内聚性”。
        ```
    5. 松散耦合性
        - 耦合标准
        ```
            1. 耦合规模。子程序的入参个数越少，耦合规模越小
            2. 密切性。
            密切性指的是两个子程序之间联系的直接程度。 
            联系越直接越好，两个子程序之间联系最密切的是参数表中的参数。 
            当两个程序直接通讯时，这个参数就像接吻时的嘴唇。 联系密切程度稍低的是作用于同一全局数据的两个子程序。 
            它们之间交流的直接性稍低。 全局变量就像是两个子程序之间的爱情，它可能消失在信中，也可能到你想要它到的地方。 
            联系程度最低的是作用于同一数据库记录或文件的两个子程序，它们都需要这个数据但却又羞于通知对方，
            这个被分享的数据就像是在课堂上传阅着的一张写有“你喜欢我吗？请回答‘是’还是‘不 是’”的纸条。
            3. 可见性。
            可见性是指两个子程序之间联系的显著程度。 编程不像是在中央情报局中工作，不会因为行动隐蔽而受到表彰，
            它更像是作广告，干得越是大张旗鼓，受到的表彰也就越多。 在参数表中传递数据是明显的，因而也是好的。 
            而通过改动全局数据以便让别的子程序来使用 它，则是一个隐蔽的联系因而也是不好的。 
            对全局数据联系进行注释以使其更明显，可能稍好些。
            4. 灵活性。
            灵活性是指改变两个子程序之间联系的容易程度。 形象地说，你更喜欢电话上的快速插口装置，
            而不会喜欢用电烙铁把铜线焊到一起，灵活性可能有一部分是由其它耦合特性决定的，但也有一些区别。 
            比如，有一个按照给定的被雇用日期和被雇用部门，寻找雇员的第一个监工的子程序，
            并命名它为 LookUpFirstSupervisor() 。 同时，还有一个对变量 EmpRec 进行结构化的子程序，
            变量 EmpRec 包括雇用日期、 雇用部门等信息，第二个子程序把这个变量传给第一个子程序。

        ```
        - 耦合层次
        ```
            1. 简单数据耦合
            如果两个子程序之间传递的数据是非结构化的，并且全部都是通过参数表进行的，这通常称作正常耦合”，这也是一种最好的耦合。
            2. 数据结构耦合
            如果在两个程序之间传递的数据是结构化的，并且是通过参数表实现传递的，它们之间就是数据结构耦合的。 
            这种耦合有时也称之为“邮票耦合”（ stamp coupling ） （ 不过我总觉得这种叫法非常奇怪）。
            如果使用恰当的话，这种耦合也不错，它与简单耦合的主要区别是它所采用的数据是结构化的。
            3. 控制耦合
            如果一个子程序通过传入另一个子程序的数据通知它该作什么，那么这两个子 程序就是控制耦合的。 控制耦合是令人不快的，因为它往往与逻辑内聚性联在一起，并且，通常都要求调用程序了解被调子程序的内容与结构。
            4. 全局数据耦合
            如果两个子程序使用同一个全局数据，那它就是全局数据耦合的。 这也就是通常所说的“公共耦合”或“全局耦合”。
            如果所使用的数据是只读的，那么这种耦合还是可以忍受的，但是，
            总的来说，全局耦合是不受欢迎的，因为这时子程序之间的联系既不密切，又不可见。 
            这种联系容易被疏漏掉，甚至可以认为它是一种由信息隐含带来的错误——信息丢失。
            5. 不合理耦合
            如果一个子程序使用了另外一个子程序中代码，或者它改变了 其中的局部变量，那么它们就是不合理耦合的。 
            这种耦合也称之为“内容耦合”。这一类耦合是不能接受的，
            因为它不满足关于耦合规模、 密切性、 可见性和灵活性中的任何一条标准。 
            虽然这是一个很紧的联系，但是这种联系却是不密切的。 改动另一个子程序中的数据无异于在其后背桶上一刀，而且,
            这背后一刀从表面上又是看不出来的。 
            由于它是建立在一个子程序完全了解另一个程序内容的基础之上的，因此其灵活性也是很差的。 
        ```
    6. 子程序长度
        - ```
            研究子程序长度有什么好处呢？如果你是一个经理，不要限制程序员们编写长于一页的子程序，
            刚才引用的资料和程序员们自己的经验都可以证明你这样作是正确的。 
            如果想编写一个长度是 100 行， 150 行或 200 行的子程序，那就按照你想的去作吧。 
            目前的证据表明，这种长度 的子程序并不更易引发错误，而其开发更为容易。
            如果要开发长于 200 行的子程序，就要小心了（这里的长度不包括注释行和空行）。
        ```
    7. 防错性编程
        - 概述
        ```
            防错性编程并不意味着要对自己的程序提高警惕，这一想法是在防错性驾驶的基础上产生的,
            在这种驾驶方法中,必须在心中时刻认为其它驾驶员的行为都是不可预测的。
            这样， 就可以在他们做出某些危险举动时，确保自己不会因此受伤。在防错性编程中，
            其中心思想是，即使一个子程序被传入了坏数据，它也不会被伤害，哪怕这个数据是由其它子程序错误而产生的。 
            更一般地说，其思想核心是承认程序中都会产生问题,都要被改动，一个聪明的程序猿就以这点为依据开发软件
        ```
    8. 子程序参数
        - 确保实际参数与形式参数匹配。（现代编辑器基本都已经杜绝了该问题）
        - 按照 输入一修改一输出 的顺序排列参数。
        - 如果几个子程序今使用了相似的参数，应按照不变的顺序排列这些参数。
        - 使用所有的参数。 
        - 把状态和“错误”变量放在最后。
        - 不要把子程序中的参数当作工作变量，应使用局部变量
        - 说明参数的接口假设，入参注释
        - 应该把一个子程序中的参数个数限制在 7 个左右
        - 考虑建一个关于输入/修改/输出参数的命名约定
        - 仅传递子程序需要的那部分结构化变量
        - 不要对参数传递作出任何设想
        ```
            有些程序员总是担心与参数传递有关的内部操作，并绕过 高级语言的参数传递机制，这样做是非常危险的，
            而且使得程序的可植性变坏。 参数一般是通过系统堆栈传输的，但这决不是系统传递参数的唯一方式。 
            即使是以堆栈为基础的传递机制， 这些参数的传递顺序也是不同的，而且每一个参数的字长都会有不同程度的改变。 
            如果你直接 与参数打交道，事实上就已经注定了你的程序不可能在另一个机器上运行。
        ```
    9. 使用函数
        - ```
            像 C 、 Pascal 和 Ada 等先进的语言，都同时支持函数和过程，函数是返回一个值的子程序， 
            而过程则是不返回值的子程序。
        ```
    10. 检查表
        - ```
            高质量的子程序
                总体问题
                    创建子程序的理由充分吗？
                    如果把一个子程序中的某些部分独立成另一个子程序会更好的话，你这样做了吗？
                    是否用了明显而清楚的动宾词组对过程进行命名？是否是用返回值的描述来命名函数？ 
                    子程序的名称是否描述了它做的所有工作?
                    子程序的内聚性是不是很强的功能内聚性？它只做一件工作并做得很好吗?
                    子程序的耦合是不是松散的？两个子程序之间的联系是不是小规模、 密切、 可见和灵活的?
                    子程序的长度是不是它的功能和逻辑自然地决定的：而不是由人为标准决定的？
                防错性编程
                    断言是否用于验证假设？ 
                    子程序对于非法输入数据进行防护了吗？ 
                    子程序是否能很好地进行程序终止？ 
                    子程序是否能很好地处理修改情况？
                    是否不用很麻烦地启用或去掉调试帮助?
                    是否信息隐蔽、 松散耦合，以及使用“防火墙”数据检查，以使得它不影响子程序之外的代码？
                    子程序是否检查返回值？
                    产品代码中的防错性代码是否帮助用户，而不是程序员？
                参数传递问题
                    形式参数与实际参数匹配？
                    子程序中参数的排列合理吗？与相似子程序中的参数排列顺序匹配吗？
                    接口假设说明了吗？
                    接口假设说明了吗？
                    子程序中参数个数是不是7个或更少？
                    是否值传递了架构话变量中另一个子程序用得到的部分？
                    是否用到了每一个输入参数？
                    是否用到 了每一个输出参数？
                    如果子程序是一函数，是否在所有情况下它都会返回一个值？
        ```
    ##### 单元小结
    - 建立子程序的最重要原因是加强可管理性（即降低复杂性），其它原因还有节省空间、改进正确性、 可靠性、 可修改性等等。
    - 强调强内聚性和松散耦合的首要原因是它们提供了较高层次的抽象性，你可以认为一 个具备这种特性的子程序运行是独立的，这可以使你集中精力完成其它任务。
    - 有些情况，放入子程序而带来巨大收益的操作可能是非常简单的。
    - 子程序的名称表明了它的质量，如果名称不好但却是精确的，那么说明它的设计也是非常令人遗憾的。 
    如果一个子程序的名称既不好又不精确，那它根本就无法告诉你程序作了些什么。 无论哪种情况，都说明程序需要改进。
    - 防错性编程可以使错误更容易被发现和修复，对最终软件的危害性显著减小。
---

* 第六章
    1. 模块化概述
    ```
        "你已经把你的子程序放入我的模块中"
        "不，你已经围绕着我的子程序设计好了模块" 
        人们对于子程序和模块之间的区别往往不很注意，但事实上应该充分了解它们之间的区别， 
        以便尽可能地利用模块所带来的便利。 Routine ”和“ Modu1e ”这两个单词的意义是很灵活的，
        在不同的环境下，它们之间的区别可能会变化很大。 在本书中，子程序是具有一定功能的，可以调用的函数或过程，
        关于这一点在第五章已经论述过了。
        而模块则是指数据及作用于数据的子程序的集合。 模块也可能是指，可以提供一系列互相联系功能的子程序集合，
        而这些子程序之间不一定有公共的数据。
    ```
    2. 模块化：内聚性与耦合性
        - 模块内聚性。与子程序内聚性的概念十分相似。都是十分简单的。 一个模块应该提供一组相互联系的服务。即"只做一件事"
        - 模块耦合。也与子程序耦合概念相似，区别在一子程序一般不会提供完整的一套功能。
    3. 信息隐蔽
        - 保密。即隐藏实现细节，对外暴露某一特定功能。
        - 常见需要隐含的信息
        ```
            1. 容易被改动的区域
            比如一个功能的核心算法逻辑可以分离出来，后期需求变动时，可能只需修改算法即可。其他模块都不需要修改
            2. 对硬件有依赖的地方
            3. 输入和输出
            4. 非编准语言特性
            5. 难于设计和实现的域
            6. 状态变量
            状态变量指示程序的状态，往往比其它数据更容易被改动。 
            在典型的情形下， 你可能最初把某一错误状态变量定义成逻辑变量。 
            但后来又发现如果把它赋成具有 NoError ， WarningError 和 FatalError 三个值的枚举型变量来实现会更好。
            7. 数据规模限制
            如果你说明一个数组中含有 15 个元素，那么你就把系统不需要的信息暴 露给了它。 
            应该保护其隐私权，信息隐蔽并不总是意味着把一系列功能装入模块这类复杂的工 作，有时，
            它简单到就是用一个像 MAX_EMPLOYEES 之类的常量来代替 1 5 ， 以便隐含它。
            8. 商业规则
            9. 复杂的数据。 可理解为需要定义存取数据的子程序（GET SET）
            10. 复杂的逻辑。 如果程序中的其余代码只需要知道结果，那么你就应该仅仅告诉它们结果。
            11. 在程序语言层次上的操作
            你的程序越是像一个实际问题的解决方案，它就越是不像程序语言结构的组合，那么， 
            其质量也就越好，应该把过于专业化的信息隐含起来
        ```
        - 信息隐藏的障碍
        ```
            绝大多数信息隐蔽障碍都是心理上的，它主要来自于在使用其它技术时形成的习惯。 
            但在某些情况下，信息隐蔽也的确是不可能的，而一些看起来像是隐蔽障碍的东西，但仅仅是 借口而已。

            1. 信息过度分散
            信息隐蔽的一个常见障碍是系统中信息过于分散。 比如在一个系统中到处分布着常数 100 。 
            把 100 当作一个常数，降低了引用它的集中程度。 
            如果把信息隐蔽在一个地方会更好， 因为这样它的值将只在一个地方改变。
            2. 交叉依赖。设计上的失败，任何情况都应该避免
            3. 误把模块数据当成全局数据
            4. 误认为会损失性能
            信息隐蔽的最后一个障碍是在结构设计和编码两个层次上，都试图避免性能损失。 
            事实上，在两个层次上你都不必担心这一点。在结构设计层次上，这种担心之所以不必要是因为， 
            以信息隐蔽为目标进行结构设计，与以性能为目标进行结构设计是不矛盾的，
            只要你同时考虑到这两点，那么就可以同时达到这两个目标。 更常见的担心是在编码层次上，
            这种担心主要是认为间接而不是直接地存取数据结构会带来运行时间上的损失，因为这样做附加了调用层次。 
            当测试了系统的性能并在瓶颈问题上有所突破时，这种担心是不成熟的。 
            为提高软件性能做准备的最好手段之一就是模块化设计，这样，在发现了更好的方案之后，
            不必改变系统其余部分，就可以对个别子程序进行优化。
        ```
    4. 建立模块的理由
        - 概述
        ```
        即使不经常使用模块，凭直觉也很可能会对可以放入模块的数据和子程序种类有所了解。 
        从某种意义来说，模块并不是人们的目标，它只是数据及对数据所进行的操作的集合，
        并且支 持面向对象的概念——抽象和封装。模块不支持继承性，因而它也并不完全支持面向对象编程， 
        描述它的这种有限的面向对象特性的词汇是 Booch 1991 年提出来的“基于对象”编程。 
        以下是一些适合使用模块的域：
        1. 用户接口
        2. 对硬件有依赖的区域
        3. 输入与输出。
        4. 操作系统依赖部分
        5. 数据管理。
        6. 真实目标与抽象数据类型。
        7. 可再使用的代码
        8. 可能发生变动的相互联系的操作。
        9. 互相联系的操作
        ```
    5. 模块质量检查表
        - 模块的质量
        ```
            模块是否有一个中心目的？
            模块是否是围绕着一组公用数据进行组织的?
            模块是否提供了一套相互联系的功能？
            模块功能是否足够完备，从而使得其它模块不必干预其内部数据？
            一个模块相对其它模块是否是独立的？它们之间是松散耦合的吗？
            一个模块的实现细节，对其它模块来说，是隐含的吗？
            模块的接口是否抽象到了不必关心其功能实现方式的地步？它是作为一个黑盒子来设计的吗？
            是否考虑过把模块再划分为单元模块？是否对其进行了充分的再划分工作？
            如果用不完全支持模块的语言编程，你是否制定了编程约定以使这种语言支持模块？
        ```
    ##### 单元小结
    - 不管调用哪一个，子程序与模块的不同是很重要的，要认真考虑子程序与模块的设计。
    - 从模块数据是被几个子程序使用的这一角度来说，它与全局数据是相同的，但从可以使用它的子程序是有限的，
    而且清楚地知道是哪些子程序可以使用它这一角度来说， 模块数据与全局数据又是不同的。 
    因此，可以使用模块数据而没有全局数据的危险。
    - 信息隐蔽总是有益的。 其结果是可以产生可靠的易于改进的系统，它也是目前流行的 设计方法的核心。
    - 创建模块的原因有许多是与创建子程序相同的。 但模块概念的意义要比子程序深远得多，
    因为它可以提供一整套而不是单独一个功能，因此，它是比子程序更高层次的设 计工具。
    - 可以在任何语言中进行模块设计。 如果所采用的语言不直接支持模块，可以用编程约定对其加以扩展，以达到某种程度的模块化。
--- 

* 第七章 高级结构设计
    1. 软件设计引论
        - ```
            软件设计”一词的意思是指，把一个计算机程序的定义转变成可以运行程序的设计方法。 
            设计是联系要求定义和编码与调试的活动的桥梁。 
            它是一个启发的过程而不是一个确定的过程，需要创造性和深刻的理解力。 
            设计活动的绝大部分活动都是针对当前某特定项目进行的。
        ```
    2. 结构化设计
        - 概述：
        ```
            结构化设计这一概念是 1 974 年在《 IBM 系统日报》（ IBM System Journal ） 一篇论文中出现的。
            在后来由 Ed Yourdon 和 Larry Constantine 
            写进《 Structured Design:Fundamentals of a Discipline of Computer Program and Systems Design 》 书中（ 1 971 ） ， 对其作了全面补充与扩展。 
            Constantine 是最初那篇论文的作者之一，而“自顶向下设计”一词则是指一种非正式的结构化设计，
            类似的词还有“逐步求精”和“分解”等，指的基本都是同一意思。 结构化设计是与其它结构化设 计方法一道使用的。

            结构化设计是由以下部分组成的：
                系统组织，系统将被设计成几个黑盒子，明确定义的子程序和模块、接口的实现细节对 其它子程序来说都是隐含的。
                开发设计的策略。
                评估设计准则。
                关于问题的明确说明，这是解决问题的指导原则。
                表达设计的图形和语言工具，包括 PDL 和结构图。
        ```
        - 选择需进行模块化的要素
        ```
            在前面几章论述了程序和模块相关好坏的标准，并提供了确定子程序和模块质量的检查表， 
            但并没有给出识别子程序和模块的方法，在本节中，将论述这一问题的指导原则。

            1.  自顶向下分解
            把程序分解为子程序的一种流行方法是自顶向下分解，也称为自顶向下设计或逐步求精。 
            其特点是从关于程序功能的粗略说明出发，逐步推进到程序要做的每一项特定的工作。 
            从粗略的层次出发往往是指从程序中的“主要”子程序出发，通常，把这个子程序画在结构图的顶部。
            以下是几项在进行自顶向下分解时要牢记的原则：
                设计高层次。 
                避免特定语言细节。
                从设计中，不应该看出打算在程序中使用什么语言，或者说当在设计中更换要用的语言时，不会产生任何麻烦。 
                暂时不指出下一层次的设计细节（与信息隐含类似）。 
                正规化每个层次。 
                检验每个层次。 
                转移到下一个层次，进行新的求精工作。
            需要把一个程序分解到什么程度呢？要持续不断地分解，直到看起来下一步进行编码要比再分解要容易为止，
            或者到你认为设计已经非常明了详细，对再分解已经感到不耐烦为止，到这时，可以认为分解已经完成了。 
            由于你比任何人都熟悉这个问题，而且也比任何人都清楚， 因此，你要确保其解决方案是很容易理解的，
            如果连你都对解决方案有些困惑的话，那么，试 想一下，又有谁会理解它呢？

            2. 自底向上合成
            有时候，自顶向下方法过于抽象以至于让人不知从何下手。如果想要进行一些具体的工作， 
            那么可以试一下自底向上的设计方法。你可以问自己，“这个系统需要做什么？” 毫无疑问，
            你能够回答这个问题。 你可以识别出系统需要具备的较低层次的功能，
            例如，你可能知道这个系统需要进行报告格式化、 计算报告总数、 用不同颜色在屏幕上显示字母等等。 
            当你识别出某些低层次功能后，再从事较高层设计可能会有把握些。
            以下是一些在进行自底向上合成时要牢记的原则：
                问自己，关于系统要做什么你都知道哪些？
                利用这一问题识别出某些低层次功能。
                识别出这些低层次功能共同的方面，将其组合到一起。
                向上一个层次，进行同样的工作，或回到顶端开始自顶向下。
            3. 自顶向下与自底向上
            自底向上与自顶向下策略的首要区别是前者是合成，而后者则是分解。 
            一个是从可控制的 零散问题出发，把它们合成到一起从而获得一个总体解决方案，
            而另一个则从总体问题出发， 将其分解成可控制的零散问题。 两种方法各有优缺点。 
            在实际使用时要详加比较。 自顶向下设计方法的特点是比较简单，人们往往擅长把大问题分解成小问题，
            而程序员们则更是擅长这点。当一个问题是用层次结构模型化的时候，自上而下的分解方法恰好与其相符。 
            自顶向下设计的另一个优点是你可以避开实现细节。 由于系统常常受到实现细节变动的干扰（比如文件结构或报告格式的变化），因此把这些细节隐含在层级结构的底部，
            而不是让它在 顶部起支配作用，是非常有益的。 这种设计方法也有它的缺点。 
            其中之一是系统的总体功能可能是很难识别的。 关于系统所 作的最重要决定之一就是如何进行第一步分解工作，
            而在自上向下设计中，刚开始接触系统， 对其了解还很少时，便不得不做出这一决定，这是很危险的。 
            它的另一个缺点是：由于许多系 统本身并不是层级结构的，因此是很难清晰地分解。 
            或许这种设计方法的最大缺点就是它要求 系统在顶层要有一个单一而又清楚的功能，
            而对于现代事件驱动系统来说，这是很难想象的。 
            自底向上设计方法的优点是它在早期就可以识别出有用的功能子程序，结果是坚实可靠的 设计。 
            如果已经开发了相似的系统，那么可以参阅一下旧系统，看看有什么可以借用的。 
            这种方法的弱点是很难单独地使用它。 因为大多数人都不善于从小的概念出发形成综合 的设想。 
            这就像一个自己组装的玩具，我想我已经组装完了，怎么盒子中还有零件呢？好在， 你不必单独使用它。 
            它的另一个弱点是 , 有时从你识别出的细节出发，无法建造出整个程序，就像你无法用砖头造出一架飞机一样。
            而且当你知道在底部需要什么功能时，你可能已经不得不进行顶层设计了。

            不过，这两种方法并不是互相矛盾的。 
            设计是一个启发的过程，就是说没有一种百试不爽 的设计方法，它总是一个尝试的过程。 
            因此，在找到好方法之前，尽可以大胆尝试，可以用自 顶向下工作一会儿，再用自底向上工作一会儿。 
            设计也是一个逐次迭代逼近的过程。 因此，你在第 n 次用自底向上方法学到的东西，
            将在 第 n ＋ l 次用自顶向下方法设计时起到很大帮助作用。
        ```
    3. 面向对象
        - 概述
        ```
            面向对象设计方法的特点是通过对实际问题的分析，从中抽象出对象，然后再用程序语言 来表现它，
            其过程主要是：识别对象中的子对象并识别出对于子对象的操作，然后再根据子对象的操作开发出一个系统。 
            面向对象设计是在程序中设计对象或模块的一种方法。 在较低的程 度上说，它也是设计单个子程序的一种方法。
        ```
        - 关键思想
        ```
            面向对象设计是建立在如下主张之上的，
            即：一个程序模型越是真实地反映了实际问题， 那么，由此产生出的程序质量越好，在多数情况下，
            关于项目的数据定义要比功能稳定得多， 因此应象面向对象设计一样，
            根据数据来进行设计，这可以使设计更稳定。对于现代编程来说， 面向对象设计中有许多思想是很重要的。

            1. 抽象
                抽象所带来的主要好处是可以忽略掉无关紧要的细枝末节问题，而专注于重要的特性。
            2. 封装
                封装是对抽象不存在地方的补充。如果抽象对你说“你应该在较高层次上看一个对象”，
                而封装则会说“你只能在这个层次上看一个对象”。
                这事实上就是 6. 2 节所述的信息隐蔽的重复。 
                你对于一个模块所知道的只是它让你知道的那些，别的什么也没有。
            3. 模块化
                面向对象设计中的模块与结构化设计中模块的含义是一致的。 
                相联系的数据和功能被放入模块，在理想情况下，模块是高度内聚而又松散耦合的。 
                同信息隐蔽一样，当模块内部发生变化时，其接口保持不变。
            4. 层次结构和继承性
                在面向对象编程中，继承性简化了编程，因为你只要写一个通用子程序来处理对象间的共同特性，
                再编写几个专用子程序去处理它们间的不同特性就可以了
            5. 对象与类
                在面向对象设计中，最后一个关键概念是对象与类。 
                对象是程序在运行时其中的任何一个实体，而类则是当你看程序清单时存在的一个静态实体。 
                对象是在程序运行时具有特定值和属 性的动态实体。
        ```
        - 面向对象设计的步骤
        ```
            面向对象设计的步骤是： 
                识别对象及其属性，它往往是数据。 
                确定对每个对象可以做些什么。 
                确定每一个对象可以对其它对象做些什么。 
                确定每个对象对其它对象来说是可见的部分——哪一部分是开放的，哪一部分是专用的。 
                确定每个对象的公共接口
        ```
    4. 对目前流行设计方法的评论
        - 概述
        ```
            如果你仔细观察日前流行的设计方法——包括结构化设计和面向对象设计——你会发现每 种方法都包括两个主要部分:
                把一个系统分解成子系统的准则

            把“设计”的意义限制在前两个要素上说明设计的核心是把系统分解成亚程序 ( Subprogram ) ，
            同时也说明亚程序的设计并不具备足够的挑战性，不值得讨论。

            一个好的系统分解的确是很有价值的，但并不是说一旦确立了好的结构，设计就可以停止了。 
            在确认出子程序的模块之后，还有许多设计工作要做。 
            伴随着某些设计方法的第三个要素，即强调应该只使用一种方法的思想，是非常有害的。 
            没有一种方法囊括了设计系统所需的全部创造力和洞察力。 强调使用一种方法将破坏设计中的思维过程。
        ```
        - 何时使用结构化设计
        ```
            结构化设计主要是一种把程序分解成子程序的方法。 它强调功能但不强调数据。 
            一个面向功能的问题域的例子是一个以批处理方式读入数据，按照可以预计的顺序对数据进行可以预计的处理并且写数据。
            结构化设计并没有把子程序组成一个协同工作子程序组的概念，也没有子程序内部设计的概念，
            除非这个子程序的内部会影响到整个系统。 因此，结构化设计非常适用于具有许多互不作用的独立功能的系统。 
            同时，它也适于那些只有几百行代码的小型程序，因为这些程序过于简单，没有建立类、 对象和属性的必要。

            结构化设计的最先提出者 Larry Constantine ， 曾经发表过一篇“对象、函数和程序可扩展性” 的文章，
            论述了把结构化设计和面向对象设计组合到一起的设计方法。 
            如果数据变动可能性很大，那么采用面向对象设计比较合适，因为它将变动可能性较大的数据独立在对象（模块）中。
            如果功能变动的可能性较大，采用面向对象设计就不太适合了，因为功能散布在许多对象（模 块）中。 
            如果功能变化的可能性比数据要大，那最好采用分解功能的结构化设计。
        ```
        - 何时采用信息隐蔽
        ```
            无论什么问题领域，都应该尽量采用信息隐蔽。 使用它没有任何危险。 
            到目前为止，联邦卫生委员会还没有发现它会发生危险，不论是设计子程序、 模块，还是对象程序，它都是很有 效的，
            因此你尽可以放心使用它。
        ```
        - 何时采用面向对象设计
        ```
            面向对象设计与结构化设计的主要区别是：面向对象设计在较高抽象层次上要比结构化设计有效.
            这是具有重大历史意义的。 因为结构化最初开发起来时程序员们正在建立定义大而复 杂的系统，到现在已经远不及如今的大规模系统那样复杂了。
            面向对象设计主要是设计模块数据和对数据操作的集合。 
            它非常适于从最顶层分解系统。 而当你识别出对象的接口并开始编码时，你往往会转向结构化设计。 
            如果你用面向对象的语言 编程，那么很难认为你没有在面向对象设计，
            因为你用面向对象方法、 信息或其它进行结构设计工作。 如果你是在用比较传统的过程性语言进行设计，
            则很容易认为你是在用较旧的结构化 设计方法，在这时，使用这一方法是很合适的。

        ```
    5. 往返设计
        - 概述
        ```
            通过组合使用主要设计方法来扬长避短是完全可能的。 
            每种设计方法都只是程序员工具箱中的一件工具，不同的工具适合不同的工作，你将从研究所有方法的启发中获益无穷。 
            下面一小节结论述了软件设计为什么困难的某些原因，并指出了如何组合使用结构化设计，面向对象设计和其它设计方法。
        ```
        -  什么是往返
        ```
            你可能会有这样的体验：当你编写程序快结束时，你非常希望能有机会再重新编写一次， 
            因为在编写过程中你对问题又有了更深的理解。 这对设计也是同样适用的，只不过在设计中这个循环的周期更短，
            带来的好处也更大，因此，你完全可以在设计过程中进行几次往返。
            这种在高层次和低层次之间往返思维过程是非常有益的，由此而 产生的结构，
            将比单纯自顶向下或自底向上产生的结构要稳定得多。
        ```
        - 设计是一个复杂的过程
        ```
            J.P Morgon 曾经说过人们在做事情时常常有两个原因：表面上冠冕堂皇的原因和真正的原因。 
            在设计中，最终结果往往看起来是井井有条的，似乎设计者从未犯过任何设计错误，
            事实上，设计过程很少有像最终结果那样井井有条。
            设计是一个复杂的过程。 因为你很难把正确答案与错误答案区分开来。 
            如果你让三个人分 别设计同一个程序，他们带回来的往往是三个大相径庭的方案，而且其中每一个看起来都非常适用。 
            它是一个复杂的过程还因为你在设计过程中曾钻过许多死胡同、 犯过许多错误。 
            说它是一个复杂的过程也是因为你不知道什么时候设计方案已经足够完善了。 
            什么时候算完成呢？对 这个问题的通常答案是“当你没有时间时”。
        ```
        -  设计是一个“险恶”的过程
        ```
            Horst Rittel 和 Melvin Webber 把烦人的问题，定义成只有通过解决它或者部分解决它，才能给出明确定义的问题。
            这个似是而非的定义事实上暗示着你不得不首先“解决”这个问题， 对其有一个清楚的定义和理解，
            然后再重新解决一遍，以获得正确的解决办法。 这一过程对软件开发就像母爱和面包对你我一样必不可少。
        ```
        - 设计是一个启发的过程
        ```
            进行有效设计的关键是要认识到它是个启发的过程。 设计中，总是吃一堑，长一智的。 
            往返设计的概念事实上解释了设计是个启发过程这一事实，因为你要把任何设计方法都只当成一种工具。
            一种工具只对一种工作或者一种工作的某一部分才有效，其余的工具适合其它的工作， 没有一种工具是万能的。 
            因此，你往往要同时使用几种工具。

            为什么非要在经验和信息都不足的情况下 草率决定呢？你完全可以在以后等经验和信息丰富时做出正确决定。 
            有些人对一次设计没能彻底解决问题会感到很不舒服，但与其很不成熟地勉强解决问题，不如把问题暂放一个，
            待到信息足够丰富时，再解决它。  
        ```
        -  受迎的设计特点
        ```
            1. 智力上的可管理性。
            对于任何系统来说，智力上的可管理性都是其重要目标之一。 
            它对于 整个系统的完整性是非常重要的，并且会影响程序员们开发和维护系统的难易程度。
            2. 低复杂性.
            低复杂性实际上是智力上的可管理性一部分，由于上述同样的原因，这点也很 重要。
            3. 维护的方便性
            维护的方便性意味着设计时要为负责维护的程序员着想。 
            在设计中，要不停地想象维护程序中将会对你的设计提出的问题。 
            应该把维护程序员当作你的听众，同时把系统设计成明白易懂的。
            4. 最小的联系性
            最小的联系性指的是按照保持子程序之间的联系最少的原则来设计，应该利用强内聚，
            松散耦合和信息隐蔽等作为指导原则来设计系统，使其内部的联系性尽可能少。 
            最小的联系性可以极大地减小综合、 测试和维护阶段的工作量。
            5. 可扩充性
            可扩充性指的是不必影响系统的内部结构，就可以对系统的功能进行强化，
            你可以改变系统的某一部分而不影响其余部分，使得最大可能性变动对系统带来的影响最小。
            6. 可重复使用性
            可重复使用性指的是把系统设计成其中许多部分是可以被其它系统借用 的。
            7. 高扇入
            高扇入指的是对于一个给定的子程序来说，应该有尽可能多的子程序调用它。 
            高扇入表明一个系统在低层次上充分利用了功能子程序。
            8. 低或中等程度扇出
            低或中等扇出指的是对一个确定的子程序来说，它所调用的子程序应该尽可能地少。 
            高扇出（大约 7 个以上）说明一个子程序控制了许多其它子程序，因此可能是很难理解的。 
            而中等扇出则表明一个子程序只把任务交给了数量较少的其它子程序，因此是比较容易理解的。 
            低扇出（少于 4 个）看起来像是一个子程序没有把足够的任务交给其余的子程序去做，但经验表明并不是这样。 
            一项研究表明有 42% 只调用一个子程序的子程序是没有错误的，有 32% 的调用 2 ～ 7 个子程序是没有错误的 , 
            而在调用 7 个以上子程序的情况中，只有 1 2% 是没有错误的（ Card, Church 和 Agresi ， 1986 ）。 
            由此， 业界认为 0 ～ 2 个扇出是最优的。
            9. 可移植性
            可移植性指的是把系统设计成很容易转到另外的环境下运行。
            10. 简练性。
            简练性指的是把系统设计得没有任何多余部分。 
            Voltaire 曾说过，当一本书不能删掉，而不是不能添补任何内容时，才可以认为它已完成了。 
            在软件中，这也是非常正确的，因为当你对系统进行改进时，你不得不对冗余的代码进行开发、 评审、 测试和维护等等工作，
            而且在开发软件的新版本时，新版本也不得不与这些冗余的代码兼容。 最有害的观点是“多加入 些又不会有害，怕什么呢？
            11. 成层设计
            成层设计指的是尽量分解的层次是成层的，这样你可以在每一个单独的层次上观察系统，同时也可以使观察的层次是连续的。 
            也就是说当你在某一层次上观察系统时，不会看到在其它层次上看到的东西。 
            你会经常遇到某些子程序和软件在几个层次上起作用。 这样会 使系统很混乱，应尽力避免。

            如果在编写一个先进系统时，不得不借用许多旧的、 设计得不好的代码，那么你可以在新系统中建立一个层 ( layer ) ， 
            与那些旧代码相联接。 精心设计这个层使它把旧代码的缺点隐含起来，从而使新层表现了一整套连续的功能。 
            然后，让程序的其余部分调用些子程序而不是直接调用旧代码。 成层设计的好处是：
            （ l ） 它可以使你避免与拙劣的旧代码直接打交道；
            （ 2 ） 一旦 你想废弃那些旧代码中的子程序的话，只要修改一下接口层就可以了。
            12. 标准化技求
            标准化技术是深受欢迎的。 一个系统使用的奇特的、 非标准的技术越多，当别人第一次读它时就会越感到可怕，也越难理解。 
            应该通过采用常用的、 标准化的技术使得人们在阅读它时是一种熟悉的感觉。
        ```
        - 检查表-高层次设计
        ```
            本表给出了在评估设计质量时，通常要考虑一些问题。 本表是 3. 4 节中结构设计检查表的补充，这个表所考虑的主要是设计质量。 
            3. 4 节中的检查表则侧重于结构设计和设计内容。 这个表中的某些内容是相互重合的。

            1. 是否使用了往返设计方法，应从几个方案中选择最好的，而不是首次尝试就确定方案。
            2. 每个子程序的设计是否都和与其相关的子程序设计一致？
            3. 设计中是否对在结构设计层次上发现但并未解决的问题作了充分说明？
            4. 是否对把程序分解成对象或模块的方法感到满意？
            5. 是否对把模块分解成子程序的方法感到满意？
            6. 是否明确定义了子程序的边界？
            7. 是否是按照相互作用最小的原则定义子程序的？
            8. 设计是否充分利用了自顶向下和自底向上法？
            9. 设计是否对问题域要素、 用户接口要素、 任务管理要素和数据管理要素进行了区分？
            10. 设计是智力上可管理的吗？
            11. 设计是低复杂性吗？
            12. 程序是很容易维护的吗？
            13. 设计是否将子程序之间的联系保持在最低限度？
            14. 设计是否为将来程序可能扩展作了准备？
            15. 子程序是否是设计成可以在其它系统中再使用的？
            16. 低层次子程序是高扇入的吗？
            17. 是否绝大多数子程序都是低或中等程度扇出的？
            18. 设计易于移植到其它环境吗？
            19. 设计是简练的吗？是不是所有部分都是必要的？
            20. 设计是成层的吗？
            21. 设计中是否尽量采用了标准化技术以避免奇特的、 难以理解的要素？
        ```
    ##### 单元小结
    - 设计是一个启发的过程。 固执地坚持某一种方法只会抑制创造力，从而产生低质量的程序。 
    坚持设计方法上有一些不屈不挠的精神是有益的，因为这可以迫使你对这种方法进行充分理解。 
    但是，一定要确信你是在不屈不挠而不是顽固不化。  
    - 好的设计是通过迭代逼近得到的：你尝试过的设计方案越多，你最终所确定的设计方案也越好。
    - 结构化设计比较适合于小规模的子程序组合，同时，它对于功能变化可能性比数据大的问题也是较适用的。
    - 面向对象设计更适于子程序与数据的组合，通常在比结构化设计抽象程度更高些的层次上适用。 
    它尤其适合于数据变动可能性大于功能变动可能性的问题。
    - 设计方法仅是一种工具，你对工具运用得好坏决定了你所设计的程序的质量。
    利用不好的设计方法，也可能设计出高质量的程序。而即使是好的方法，如果运用不当的话,也只能设计出拙劣的程序。 
    但不管怎样，选择正确的工具更容易设计出高质量的软件。
    - 许多关于设计的丰富而有用的信息都是在本书之外的。在这里所论述的，不过是冰山的一角而已。(举一反三，根据已有理论灵活使用才是学习的最终效果)
---

* 第八章 生成数据
    1. 检查表
    ```
        生成类型
            程序中是否对每种可能变动的数据都使用了不同的类型？
            类型名称是面向客观世界中的实体类型而不是面向程序语言中的类型吗？
            类型名称是否有足够的表现力来帮助说明数据？
            避免重新定义已定义的类型了吗？
        说明数据
            是否使用了模板为简化数据说明工作？并用其来统一说明形式？
            如果所用的语言支持隐式说明，是否采取了补救措施？
        初始化
            是否每个子程序都对输入参数进行了检查以保证其有效性？
            是否在使用变量的位置附近对其进行初始化的？
            是否恰当地对计数器和指针进行了初始化？是否在必要时对其进行了重新初始化？
            在反复执行的代码段中，是否对变量进行了恰当地重新初始化？
            用编译程序编译代码时是否是无警告的？
    ```
    ##### 单元小结
    - 在你的工具箱中需要一张全部数据结构的清单，以便用最合适的方法处理每一种问题。
    - 建立自己的数据类型，以增加程序的可变动性，并使其成为自说明的。
    - 数据初始化很容易产生错误，因此应采用本章推荐的技术来避免由意外初始值所产生的错
    误。
---

* 第九章 数据命名
    1. 名称选择
        - 概述
        ```
            在给变量命名时，你不能像给小狗起名时那样仅仅挑有趣或好听的名字。但除了实体不同
            之外，变量与变量名和狗与狗名实际是同一回事。
            因此，一个变量的好坏在很大程度上是由其名字决定的。所以在选择变量名时一定要谨慎。
        ```
        - 命名时要考虑的最重要问题
        ```
            在给变量命名时，考虑的问题是变量名称是否完全而又准确地描述了变量所代表的实体。
            一个有效的方法是用自然语言（如英语）将变量所代表的实体描述出来。往往这一描述本身便
            是最好的名称，因其不含缩写它很容易读懂，又由于它是对实体的全面描述。因此不会与其它
            实体相混淆，而且因为它与概念相近，所以也很容易记。
        ```
        - 面向问题
        ```
            一个好记的名字通常是面向问题而不是解决问题的。一个恰当的名字往往说明是“什么”
            而不是“怎样”。通常，如果一个名称指向计算的一方面而不是指向问题，那么可以认为之是个“怎样”而不是“什么”的名称。
            要避免使用这种名称而要使用面向问题的名称。
        ```
        - 最佳名称长度
        ```
            名称的最佳长度应介于MaximumNumberOfPointsSincel896和x之间。太短的名字往往表示
            不出完整的意思，而用x1和x2来表示的问题，即使你能找出x1代表的是什么，也很难发现x1和x2之间有什么联系。
            太长的名字难以输入，而且会对软件的可视结构产生破坏作用。Gorla和Benander在1990年发现当变量名长度在
            10到16个字母时，COBOL程序最容易调试。
            而变量名称长度在8到20个字母时，程序调试的难易度几乎是一样的。这一准则并不是说你必须把所有变量名长度都限制在
            9到15或10到16个字母之间。但这确实要求你检查一下，程序中变量名长于这个标准的那些变量，确保清楚程度符合需求。
            以下是对一些变量名的评价，或许会给你一些启迪：
            名称太长的：
            NumberofPeopleOnTheUS0lympicTeam
            NumberOfSeatsInTheSaddleDome
            MaximumNumberOfPointsSince1896
            名称太短的：
            N，NP，NTM
            N，NS，NSISDM，MP，Max，Points
            合适的：
            NumTeamNumbers，TeamMbrCount，cTeamMbrsNumSeatslnDome，SeatCount，cSeat,MaxTeamPoints，Record Points，cPoints
        ```
        - 变量名的作用域
        ```
            短的变量名总是不好的吗？当然不总是。
            当你用i作为一个变量名时，这个较短的长度就可以说明某些问题，比如，这个变量是一个临时变量，只在有限的操作范围内才是有效的。
            当程序员读到这样一个变量时，他应该能猜到这个变量只在几行内使用。如果你把某个变量称为i，
            你就等于在说“这个变量仅作为循环计数器或数组索引数使用，在这几行代码外没有任何意义”。
            由W．J Hansen进行的一项调查表明，较长的名字适于较常使用的变量或全局变量。而较短的名字则适于局部变量或循环变量（1980）。
            但短名字会产生许多问题，有些程序员把避免使用它们作为防错性编程的准则。
        ```
        - 变量名中的反义词
        ```
            应恰当使用反义词。使用关于反义词的命名约定可以帮助保持连续性，同时也可以提高可读性。
            像first/last这样一组反义词是很容易理解的，但first/end就有些让人摸不着头脑了，以下
            是一些比较容易理解的反义词。
            add/remove
            begin/end
            create/destroy
            insert/delete
            first/last
            get/release
            increment/decrement
            put/get
            up/down
            lock/unlock
            min/max
            next/previous
            old/new
            open/close
            show/hide
            source/destination
            source/target
            start/stop
        ```
    2. 特定数据类型命名
        - 概述
        ```
            除了对数考虑据命名通常需要的一些问题之外，对特殊数据类型必须给予特殊的考虑。
            本书将论述循环变量、状态变量、临时变量、逻辑变量、枚举变量和命名常量的命名问题。
        ```
        - 循环变量命名
        ```
            由于几乎每个程序中都含有循环，因此，对循环变量的命名问题加以专门考虑是十分必要的。
            总之，应尽量避免使用i、j、k来命名。如果不得不使用它们的话，那除了把它们用作循环控制变量之外，最好不再用作别的变量名。
            这一约定是众所周知的，如果不遵守它只会引起别人的困惑。
        ```
        - 状态变量命名
        ```
            状态变量描述的是程序所处的状态。下面论述了它们的命名原则。
            用比flag更好的名称来命名变量，最好不用flag作为状态变量的名字。
            之所以要避免使用flag作为标志名称，是因为它不能告诉你关于这个标志的任何信息。
        ```
        - 临时变量命名
        ```
            临时变量用来保存中间运算结果，如用作暂时保留某个位置或保留内务操作值。
            通常把它们叫做TEMP或X等没有什么意义的名字。临时变量的使用往往标志着程序员还没有完全理解
            程序。而且，由于名义上给了它一个“临时”的状态，因而程序员们在处理它们时往往会采取漫不经心的态度，从而增大了出错机会。
        ```
    3. 命名约定
        - 概述
        ```
            有些程序员往往坚持标准和约定，这是有其原因的。
            然而，某些原则和约定过于刻板而且往往是无效的，这只会破坏你的创造力和程序的质量，这实在是个不幸，
            因为有效的标准和约定是你的工具箱中最为有效的工具之一。
            这一节将讨论为什么及什么时候和怎样建立你自己的命名标准。
        ```
        - 为什么要建立约定
        ```
            约定可以带来如下好处：
            1. 它们可以使更多的东西成为独立的。通过做出一个总体决定而不是许多局部决定，你可以把精力放到更重要的程序特性上。
            2. 它们可以帮助借鉴其它项目的经验并移植自己的经验。相似的名字可以使你更容易并且更自信地猜测陌生变量的功用。
            3. 它们可以使你更快地熟悉新项目的代码。与一套连贯的而不是各式各样、东拼西凑的代码打交道显然要容易得多。
            4. 防止一变量多名。如果没有命名约定，你很可能给一个变量取两个或更多的名字。
            例如，你可以把所有点的个数称作PointTl又称作Ttl_Points。这对于你来说可能没什么，因为你是程序的作者。
            但对以后要读这个程序的程序员来说，这很可能会使人困惑。
            5. 弥补语言的缺陷。你可以利用命名约定来仿效命名常量或枚举类型，
            这一约定可以区分局部、模块和全局变量，也可以并入编译程序所不支持类型的信息。
            6. 命名约定还可以强化相关项之间的联系。如果你使用的是结构化数据，那么编译程序会自动考虑到这一点；
            如果所用的语言并不支持结构化数据，可以通过命名约定来补充它。像Addr，Phone和Name等名称并不表示变量是相联系的。
            但如果你决定所有的雇员数据变量名都要用Emp作为前缀，那么毫无疑问，EmpAddr、EmpPhone和EmpName就是联系的变量了。
            通过建立伪结构化数据，弥补语言的缺陷。

            关键是有约定总比没有约定好，哪怕约定是随意的也罢，约定的效力并不是由某一确定的约定，
            而是由约定存在决定的，它可以增加代码的结构并减少你的担心。
        ```
        - 什么时候使用命名约定
        ```
            关于这个问题并没有一成不变的答案。但在以下几种情况下，使用命名约定我认为还是值得的。
            1. 当同时有几个程序员从事一个项目时。
            2. 计划把程序交给另一个程序员进行修改和维护时（这时命名约定是必不可少的）。
            3. 当你的程序将由其它程序员来评审时。
            4. 当程序规模过大，需要按部分来考虑它时。
            5. 当一个项目中要频繁使用某些不常见的词汇，而又想开始编码时。
            6. 命名约定总是有益的，上述准则可以帮助你确定在某一项目中命名约定使用的广泛程度。
        ```
        - 正式程度
        ```
            不同约定的正式程度是不同的。一个简单的约定可能只有一句话，“使用有意义的名称”。
            略微正式的约定将在下节讨论。更正式些的约定将9.5节中论述。
            一般来说，约定正式程度是由从事一个程序的程序员人数、程序的规模和程序的预测生存期决定的，在小型程序中，严格的约定往往是不必要的。
            如果是需要几个人协作（可能是在开始，也可能是在程序生存期内的某个时间）的程序，那么可读性往往要依赖正式的命名约定来保证。
        ```
    4. 非正式命名约定
        - 概述
        ```
            绝大多数项目都采用如下所述的非正式命名约定。
        ```
    5. 要避免的名称
        - 避免容易产生误会的名称或缩写
        ```
           要确认变量名称是清楚的。FALSE通常是指TRUE的反义词，如果用它当“Fig and Almond Season”的缩写显然是不合适的。 
        ```
        - 避免含义相同或相近的名字。
        ```
            如果可以交换两个变量的名称而不致影响程序，那说明这两个变量都应重新命名。
            如Input和InVal，RecNum和NumRecs等每两个的意义都很相近，如果在同一程序中同时使用它们来命名两个变量，就非常容易引入某些难以察觉的错误。
        ```
        - 避免使用含义不同但拼写相似的名称。
        ```
            如果发现两个变量名称拼写相似但含义不同，那应对其中一个重新命名或改变缩写技术，比如ClientsRecs和ClientsReps这样的名称就应避免。
            因为它们之间只有一个字母不同，而且这一字母很难辨别，两个名称之间至少应有两个字母不同，或者把不同的字母放在词首或词尾。
            如用ClientRecords和ClientsReports来分别代替上述两个名称显然要好得多。
        ```
        - 避免使用发音相同或相近的名称。
        ```
            如Wrap和rap。因为这将使你在与同事讨论问题时遇到很多麻烦。
        ```
        - 避免在名称中使用数字。
        ```
            如果变量名中的数字的确很有意义的话，应使用数组而不应使用单个变量。
            如果使用数组不合适的话，那么使用含有数字的变量名更不合适。
            比如，应避免使用FILE1、FILE2和Total1、Total2这类名字。
            可以用很多办法来区分两个变量，但不要采用在变量名末尾加数字的方法。
            我不敢说应绝对禁止在变量名中使用数字，但起码你应尽全力避免这种用法。
        ```
        - 避免在名称中改写字母。
        ```
            记住单词的拼写是一件困难的事情，而记住改了字母的单词则更困难。
            例如，通过改写字母把highlight写成hilite以节省三个字母，将使得读者很难记住这个单词被改写成什么样了，是Hilite，
            还是Hai-a-lai-t？谁知道呢？
        ```
        - 避免常见的容易拼写错的单词。
        - 不要单纯通过大写来区分变量名。
        - 避免使用标准子程序名和已定义的变量名。
        - 不要使用与变量所代表的实体没有任何联系的名字。
        - 避免使用含有难以辨认字符的变量名称。
    6. 检查表
    ```
        通用命名约定
        变量名称是否完全准确地描述了变量代表的是什么？
        变量名是否指向是客观世界中的问题，而不是关于这问题的用程序语言表达解决方案?变量名称是否是够长，使得你不必破译它？
        变量名中如果含有计算限定词的话，是否将其放在最后？
        是否在名称中用Count或Index来代替了Num？
        对特殊类型数据的命名
        循环变量的名称是有意义的吗？（如果循环体较长是嵌套循环的话，应用有含义的名称来代替i、j、k之类的名称）
        是否用更富于含义的名称来代替了被叫作"tempotarg"的临时变量？
        当逻辑变量的值是"True"时，它的名称是否充分表达了其含义？
        是否用前缀或后缀来表明了某些枚举类型是一类的？
        如用Color来作ColorRed，ColorGreen，ColorBlue等枚举类型的前缀。
        命名常量的名称是否是指向它们代表的实体而不是它们所代表的数值的？
        命名约定
        命名约定是否区分了局部、模块和全局数据？
        命名约定是否对类型名称、
        命名常量、
        枚举类型和变量进行了区分？
        在不支持强化仅供子程序输入参数的语言中，命名约定是否对这类参数进行了标识？
        命名约定是不是与程序语言的标准约定尽可能地相容？
        对于语言中没有强制的子程序中仅做输入的参数，是否约定将它标识了？
        是否对名称进行了格式化以增强程序的可读性？
        短名称
        代码是否使用了长名称？（除非有必要使用短名称）
        是否避免了只省略一个字母的缩写？
        所有单词保持缩写的连续性了吗？
        所有的名称都是容易发音的吗？
        是否避免了会引起错误发音的名称？
        是否在注释表中对短变量名进行了注释？
        避免如下这些常见的命名错误了吗
        易引起误会的名称
        含义相似的名称
        仅有一或两个字母不同的名称
        发音相似的名称
        使用数字的名称
        对单词作改写以使其比较短的名称
        英语中常拼写错的名称
        标准库子程序或已定义的变量名又定义了
        完全是随意的名称
        含有难以辨识字母的名称
    ```
    ##### 单元小结
    - 恰当的变量名是可读性好的必要条件之一。特殊的变量如循环变量和状态变量要予以特殊考虑。
    - 命名约定可以区分局部、模块和全局变量。同时它还可以区分类型名称，比如可以对命名常量、枚举类型和变量加以区分。
    - 不管你从事的是哪种项目，都应该采用命名约定。所采用的命名约定取决于程序的规模和从事这一程序的程序员的人数。
    - 匈牙利约定是一种非常有效的命名约定，比较适于大规模项目和程序。
    - 在现代编程语言中几乎不需要采用缩写技术。
---

* 第十章
    1. 作用域
        - 概述 
        ```
            作用域指的是变量名称的影响范围，也可称之为可见性，即在程序中某一变量被知道和提及的范围。
            作用域有限或很小的变量只在程序的一小部分中被知道，
            如：一个只有在一个小循环中用到的循环变量。作用域大的变量则在程序中的许多地方被知道
        ```
        - 尽可能减小作用域。
        ```
            你所采取的方法往往取决于你“方便性”和“可管理性”这两个问题的看法。
            许多程序员喜欢用全局变量。因为全局变量存取很方便而且程序员们不必围着参数表和模块命名规则转。
            事实上，这种存取方便性是与由全局变量引入的危险共存的。
            总之，应尽量避免使用全局变量以减小作用域。
        ```
        - 把对某一变量的引用集中放置。
        ```
            即声明与使用尽量位置接近。易读。
        ```
    2. 持久性
        - 概述
        ```
            假定的某个变量的持久性要长于其实际持久性时，就会出现问题。
            变量就像放在冰箱中的牛奶，你认为它可以保存一星期，但有时可以保存一个月，
            有时则五天就坏了。变量的持久性也是同样不可测的。
        ```
        - 因该注意的
        ```
            以下是可以使你避免这种错误的几个步骤；
            在程序中加入调试代码来检查变量的值是否合理。如果不合理的话。产生一个警告信息来提示检查不恰当的变量初始化。

            在写代码时假定变量已经失效。

            养成在恰好使用某一变量之前对其进行初始化的习惯。如果发现使用的变量附近没有对它的初始化，那么你就要小心了。
        ```
        - 赋值时间
        ```
            一个对程序的维护性和可读性有深远影响的主题是“赋值时间”——把变量的值和变量联系在一起的时间。
            是在写程序时把它们联系在一起？还是在编译、加载或者程序运行时把它们联系在一起？
            应该尽可能地晚一些将它们联系在一起。通常，越是晚一些给变量赋值，代码的灵活性便越大。
            
            现代微服务表现为：设置数据中心。各服务监听所需资源
        ```
    3. 变量功能单一性
        - 应使每一个变量只具有一个功能。
        ```
            有时人们会试图在两个不同的地方使用同一变量来进行两个不同的活动。
            通常，变量名对其中的一个活动来说是不恰当的，
            或者在两种情况下都充当了“临时变量”的角色（且是用无意义的X或Temp来命名的）。
        ```
        - 避免使用具有隐含意义的变量。
        ```
            一个变量具有一个以上功用的另一种情况是同一变量取值不同时，其代表的意义也不同。
        ```
        - 保证所有说明的变量。
        ```
            与用一个变量来承担两项工作相反的另一个极端是根本不用它，
            而研究表明未被使用的变量往往是与出错率高相联系的。
            因此，要养成确实用到每一个说明变量的习惯。某些编译程序会对说明但未用到的变量给出警告。
        ```
    4. 全局变量
        - 概述
        ```
            全局变量在程序的任何地方都可以进行存取。
            有时它也被非正式地用来指可存取范围大于局部变量的变量，如在某个单一文件中可以随处存取的模块变量。
            但是，在单独一个文件中随处可存取，本身并不能表示某一变量是全局的。
            绝大多数有经验的程序员都认定使用全局变量要比局部变量危险，
            同时他们也认为利用几个子程序来存取数据是非常有益的。
            尽管对使用全局数据的危险性有许多附和的意见，但研究发现全局变量的使用与错误率上升之间并无联系。
            即使使用全局变量是没有危险的，使用它也决非最好的编程方法。本书其余部分将讨论由此而引入的问题。
        ```
        - 伴随全局变量的常见问题
        ```
            如果不加选择地使用全局变量，或者不使用它们就感到很不方便，
            那么你很可能还没有充分意识到信息隐蔽和模块化的好处。
            模块化和信息隐蔽可能并不是最终真理，但它们对程序的可读性和维护性的贡献是令其它技术望尘莫及的，
            一旦你懂得了这一点，你就会使用与全局变量关系尽可能少的子程序和模块。

            1. 对全局数据的疏忽改变。
            2. 伴随全局变量的奇怪的别名问题。
            3. 有全局数据的代码重入问题。
            4. 全局数据妨碍重新使用的代码。
            5. 全局变量会损害模块性和可管理性。
        ```
        - 使用全局数据的理由
        ```
            1. 保存全局数值，有时候需要在整个程序中都要用到某些数据。(只读数据居多,如运行配置等)
            2. 代替命名常量。
            3. 方便常用数据的使用。
            4. 消除“穿梭”数据。
            有时候把某个数据传入一个子程序中仅仅是为了使它可以把这一数据传入另一个子程序中，
            当这个传递链中的某个子程序并没有用到这个数据时，这个数据就被叫做“穿梭数据”。使用全局变量可以消除这一现象。
        ```
        - 怎样降低使用全局数据的危险
        ```
            1. 先使所有变量都成为局部的，然后再根据需要把其中某一些改为全局变量。
            2. 区分全局和模块变量。
            3. 建立使你一眼即可识别出全局变量的命名约定。
            4. 建立一个清楚标出所有全局变量的注释表。
            5. 使用加锁技术来控制对全局变量的存取。
            6. 加锁技术在开发阶段是有用的。
            7. 不要通过把数据放人庞大的变量，同时又到处传递它来掩盖你使用了全局变量的事实。
        ```
        - 用存取子程序来代替全局数据
        ```
            存取子程序的优点:
            1. 可以对数据进行集中控制。如果你以后又找到了更合适的数据结构，那么不必在每一处涉及到数据的地方都进行修改，
            而只修改存取子程序就可以了，修改的影响可以被限制在存取子程序内部。
            2. 可以把所有对数据的引用分隔开来，从而防止因其错误造成的影响蔓延。
            怎样使用存取子程序:
            以下是关于存取子程序理论与应用简短论述：将数据隐含在模块中，编写可以使你访问并修改数据的子程序，
            数据所在模块之外的子程序要求存取数据时，应让它通过存取子程序而不直接地存取模块内的数据。
            1. 要求所有子程序来对数据进行存取操作。
            通过存取子程序将数据结构隐含起来。通常需要两个子程序，一个读取数据的值，而另一个用于赋给它新值。
            除去几个可以直接存取数据的服务性子程序，其它子程序都应通过存取子程序接口来对数据进行存取。
            2. 不要把所有的全局数据都放入同一个模块中。
            3. 在存取子程序中建立某种程度的抽象。
            4. 把对数据的所有存取保持在同一抽象水平上。
        ```
        - 检查表
        ```
            一般数据
                是否已经使变量的作用域尽可能地小？
                是否把对变量的使用集中到了一起？
                控制结构与数据结构是相对应的吗？
                每个变量是否有且仅有一个功能？
                每个变量的含义都是明确的吗？是否保证了每个变量都没有隐含的意义？
                每一个声明过的变量都被用到了吗？
            全局变量
                是否是在迫不得已的情况下，才使某些变量成为全局的？
                命名约定是否对局部、模块和全局变量进行了区分？
                是否说明了所有全局变量？
                程序中是否不含有伪全局变量——传往各个子程序的庞大而臃肿的数据结构？
                是否用存取子程序来代替了全局数据？
                是把存取子程序和数据组织成模块而不是随意归成一堆的吗？
                存取子程序的抽象层次是否超过了程序语言实现细节？
                所有相互有联系的存取子程序，其抽象程度都是一致的吗？
        ```
    ##### 单元小结
    - 尽量减小变量的作用域。把对变量引用集中到一起，应尽量使变量成为局部或模块的，避免使用全局变量。
    - 使每个变量有且仅有一个功能。
    - 并不是因为全局数据危险才避免使用它们，之所以避免用它是因为可以用更好的技术来代替它。
    - 如果全局数据确实不可避免的话，应通过存取子程序来对其进行存取操作。存取子程序不仅具备全局变量和全部功能，而且可以提供更多的功能。
---

* 第十一章
    1. 常数
        - 以下是一些可以减少数据使用错误的措施:
        ```
            1. 避免"奇异数"(magic numbers)。“奇异数”指的是出现在程序中间的不加解释的常数。如果你所用的语言支持命名常量的话，那就用命名常量来代替它。
            如果无法使用命名常量的话，应考虑使用全局变量。
            2. 在需要时可以使用常数“0”或“1”。
            3. 采取预防被"0"除的措施。
            4. 明显进行类型转换。
            5. 避免混合类型比较。
            6. 注意编译程序的警告。
        ```
    2. 整型数
        - 以下是一些在使用整型数时应该牢记的准则
        ```
            1. 检查整型相除。
            2. 检查整型是否溢出。
            3. 检查中间结果是否溢出。
        ```
    3. 浮点数
        - 以下是使用浮点数时需要特殊考虑的一些问题:
        ```
            1. 不要在数量级相差太大的数之间进行加减运算。
            2. 避免相等比较。
            3. 防止舍入误差。
        ```
    4. 字符和字符串
        - 以下是使用字符串时应注意的几个问题，其中第一条适于所有的语言:
        ```
            1. 避免“奇异字符和字符串”。
            2. 警惕边界错误。
        ```
    5. 逻辑变量
        - 概述
        ```
            1. 使用逻辑变量来说明程序。
            2. 使用逻辑变量来简化复杂的判断。即将逻辑运算变现为一个变量值或者一个函数值。变量或函数命名语意化。
            3. 如果必要的话，建立自己的逻辑类型。更具语意化。0和1 可以重新定义IsProduct类型来表示更具语意
        ```
    6. 枚举类型
        - 概述
        ```
            1. 使用枚举类型来提高可读性。
            2. 使用枚举类型来提高可靠性。
            3. 使用枚举类型来改善易修改性。
            4. 用枚举类型来代替逻辑变量。(逻辑变量一般很少直接使用bool,因为情况往往不会只有两种)
            5. 检查无效值。(枚举之外为无效类型)
            6. 把枚举类型的第一个入口保留为无效的。在说明枚举类型时应把第一个值保留为无效值。比如0
            许多编译程序都把枚举类型中第一个元素的值赋为零。把被赋为0值的那个元素说明为无效，
            可以帮助找出不恰当初始化的变量，因为当它们失效时更容易为0。
        ```
    7. 命名常量
        - 概述-使用
        ```
            1. 在数据说明中使用命名常量。(一般使用const来声明常量，表示不可修改的固定值)
            2. 避免常数值。
            3. 使用全局变量来模拟命名常量。
            4. 一致地使用命名常量。应强制要求使用常量
            在程序中一会儿使用命名常量，一会儿使用常数值,而且它们代表的又是同一实体的话，那将是非常危险的。

        ```
    8. 数组
        - 概述
        ```
           数组是最简单也是最常见的结构化数据。在某些语言中，数组也是唯一的一种结构化数据。
           数组包括同属于一种类型的一组元素，并且是通过下标直接存取的。下面是使用数组时应注意的一些问题。 
        ```
        - 使用
        ```
            1. 确保所有的数组下标都没有越界。
            2. 把数组当作顺序性结构。
            3. 检查数组边界。
            4. 对于多维数组，要保证其下标的顺序是正确的。
            5. 警惕下标的错误交叉.
            6. 使数组的长度留有一定裕度。
        ```
    9. 指针
        - 概述
        ```
            指针是现代编程中最容易出错的区域。使用指针是非常复杂的，
            只有你对所用编译程序内存管理方式有非常深刻理解之后，才能正确使用它。
        ```
        - 理解指针
        ```
            1. 内存中的存储单元
            内存中的存储单元就是地址，通常是用十六进制数来表示的。
            指针本身只含有地址，要使用指针指向的数据，你必须到达那个地址并解释那个内存存储单元中的内容。
            如果你看一下那个存储单元中的存储信息，会发现其中只不过是一些位的组合而已，必须对它加以解释才能使它有意义。
            2. 怎样解释存储单元中的内容
            解释存储单元中内容的基础是指针的基本类型。如果指针指向一个整数，它的真实含义是编译程序把由指针提供的存储单元解释为一个整数。
            当然，可能会出现整数指针、字符串指针和浮点数指针同时指向同一个存储单元的情况，而此时只有一个指针正确地解释了该单元中的内容。
        ```
    10. 检查表
    ```
        常数
        •代码中是否避免了”奇异数”(常数？)•程序中是否采取了措施来防止出现被“0”除错误？
        •类型转换是显式进行的吗？
        •如果在同一个表达式中出现了两种不同类型的变量，是否对表达式按照你的意愿进行求值？
        •程序中是否避免了混合类型比较？
        •在编译过程中是没有警告的吗？整型数
        •使用整型数相除表达式的结果是否与预期的一致？
        •整型数表达式中是否避免了整型数溢出问题？
        浮点数
        •是否避免了数量级相差过大的数之间加减运算？
        •程序中是否系统地采取措施来防止舍入误差问题？
        •程序中是否避免了对浮点数进行相等比较？字符和字符串
        •程序中是否避免了常数型字符和字符串？
        •对字符串的引用是否避免了边界错误？
        •若是用C写成的程序，是否是把字符数组和字符串指针区别对待的？
        •若程序是C写成的，是否遵守了把字符串长度说明为CONSTANT+1这一约定？
        •是否用字符数组代替指针？
        •在C语言程序中，是否把字符由初始化成了NULL以避免出现无限长字符串？
        •在C语言程序中，是否用strncpy()代替了strcpy()？并且用了strncat()和strncmp()？
        逻辑变量
        •程序中是否使用了附加的逻辑变量来说明条件判断？
        •程序中是否使用了附加的逻辑变量来简化条件判断？枚举类型
        •程序中是否用枚举类型代替了命名常量来改善可读性、可靠性和易改动性？
        •是否用了枚举类型代替逻辑变量以改进可读性和灵活性？
        •在使用了枚举类型的判断中是否检查了无效值？
        •枚举类型的第一个入口是否是保留为无效的？
        命名常量
        •在数据说明中使用的是命名常量吗？
        •是否一致地使用了命名常量，而不是一会儿使用命名常量，一会儿使用数值？
        数组
        •是否所有的下标都在数组界限之内？
        •是否对数组所有的引用都没有发生越界错误？
        •多维数组的下标排列顺序正确吗？
        •在嵌套循环中，作为循环变量的数组下标是正确的吗？是否出现了交叉错误？指针
        •是否把指针操作独立在函数中？
        •指针引用是有效的吗？是否误用了悬挂指针？
        •程序中在使用指针之前，是否对它进行了检查?
        •在使用由指针指向的变量之前，是否对其有效性进行了检查？
        •在释放指针之后，是否把它们的值赋成了NULL或NIL？
        •为了提高可读性，程序中是否使用了所有需要用的指针变量？
        •链表中的指针是否是按正确的顺序释放的？
        •程序中是否分配了备用内存空间以作为内存溢出时拯救数据和工作努力的降落伞？
        •是否是在万不得已时才使用指针的？
    ```
    ##### 单元小结
    - 使用各种特定的数据类型意味着需要记住许多种规则。
    因此要用上面的检查表来确认你已考虑过了所有常见问题。
---

* 第十二章 复杂数据类型
    1. 记录与结构
        - 以下是使用结构化数据的几点原因：
        ```
            1. 使用结构化数据来表明数据间的关系。
            结构化数据把同类的所有数据都集中在一起。有时读懂一个程序最大的障碍是找出哪一个数据是与另外一个数据相联的。
            2. 使用结构化数据来简化对成块数据的操作。
            你可以把相关的数据组合进一个数据结构中，然后对这一结构进行操作。对数据结构进行操作要比对每一个元素进行同样操作容易得多。
            而且可读性更好、代码行数相对也要少些。
            3. 使用结构化数据来简化参数表。
            4. 使用结构化数据来降低维护工作量。
        ```
    2. 表驱动方法
        - 概述
        ```
            程序员们经常谈到“表驱动”方法，但是课本中却从未提到过什么是“表驱动”方法。
            表驱动方法是一种使你可以在表中查找信息，而不必用逻辑语句(if或case)来把它们找出来的方法。
            事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。但随着逻辑链的复杂，表就变得越来越富于吸引力了。
        ```
    3. 抽象数据类型(ADTS)
    ##### 单元小结
    - 恰当地对数据进行结构化，可以使程序更简单、更容易理解也更容易维护。
    - 可以用表来代替复杂的逻辑结构。当你被程序的复杂逻辑迷惑时，应考虑是否可用查寻表来简化程序。
    - 抽象数据类型是降低复杂性的有力武器。它使你可以分层编写程序，而且是从问题域而不是程序语言细节来编写顶层的程序。
---

* 第十三章 顺序程序语句
    1. 必须有明确顺序的程序语句
        - 概述
        ```
            当程序语句间有依赖关系时，你需要把它们按一定的先后顺序组织起来而使这种依赖性更明显。下面提供一些这方面的指导。
            1. 组织代码使它们间的依赖关系明显。
            2. 子程序的名字应当清轻地表明依赖关系。
            3. 使用子程序参数使依赖关系明显。
            4. 注明不明确的依赖关系。
        ```
    2. 与顺序无关的程序语句
        - 概述
        ```
            可能有这种情形，即代码中某些语句或程序块的先后顺序并不重要，一个语句并不依赖于或说逻辑上从属于另一些语句，
            但实实在在的情况是，次序是影响可读性、性能、维护性的。而且当语句执行顺序的依赖关系不存在时，
            可用下面的准则来组织这些语句或程序块的顺序。指导原则是“接近原则”，使相关操作组织在一起。
        ```
    3. 检查表
        - 组织顺序式程序代码
        ```
            把语句间的依赖关系表示得很清楚吗？
            子程序名是否把依赖关系表示得很清楚？
            子程序的参数是否把依赖关系表示得很清楚？
            若代码的依赖关系不清楚，用注释注明了吗？
            代码能从上读到下吗？
            变量的出现靠得很近吗？——从跨度和存活时间来考虑。
            是否把相关语句组织在一起？
            是否把相对独立的各相关语句写成子程序了？
        ```
    ##### 单元小结
    - 组织顺序式代码最好的原则是整理出依赖关系。
    - 用合适的子程序名、参数表、注释来标明依赖关系。
    - 如果代码没有明显依赖关系，把相关语句组织在一起，特别是使用同一参数的那些语句。
---

* 第十四章 条件语句
    1. if语句
        - 简单if-then语句
        ```
            编写if语句时请参考以下几点：
            1. 在代码中，先按正常情况的路径往下编写，然后再写异常清况。(在golang中，一种情况是一个if，if之后的代码假设之前的都是正常流程)
            2. 在出现等号情况时，一定要弄清程序的流向。（边界情况考虑，一般逻辑判断其实不应该直接使用==,而是类似 <= OR >= ）
            3. 把正常情况放在if后面而不是else后面。
            4. if语句后跟上一个有意义的语句。即可以对逻辑变量取反来让代码存在于if块中而不是在else块中
            5. 检查else语句的正确性。即边界区分要清晰，避免存在没有处理的情况
            6. 检查if语句和else语句是否弄反了。即确认逻辑变量与其对应的代码块是否对应。反正逻辑搞反了
        ```
        - if-then-else语句
        ```
            以下几条是在编写if-then-else时要遵循的：
            1. 用布尔函数调用简化程序。即当逻辑判断比较复杂的时候应封装一个子程序来返回一个bool来控制if是否执行
            2. 把最常见的情形放在最开始。
            3. 保证覆盖全部情况。 最后用一个else语句处理那些你未曾想到的错误信息。
            4. 假如你所使用的语言支持别的结构能代替If-then-else，替换掉if-then-else形式。
        ```
    2. case语句
        - 选择最有效的方法来组织各种情况
        ```
            1. 把各种情况按字母或数字顺序组织。
            2. 把正常情况的事件放在最开始。
            3. 按出现频率组织情况。
        ```
        - 用case语句该注意的几点
        ```
            1. 使每种情况对应的执行语句最简单。 一般封装专门子程序取处理对应case分支
            2. 不要为了用case语句而去定义伪交量。
            3. 若用缺省语句只用合法的缺省。
            3. 用缺省语句检查错误。
        ```
    3. 检查表
        - 条件语句
        ```
            if-then语句
                •正常情况路径在代码中流向是否很分明？
                •if-then语句在出现等号时流向是否正确？
                •else语句是否有必要？
                •else语句正确吗？
                •if语句和else语句正确吗？它们是否弄反了？
                •正常情况是否跟在if后而非else后？
            if-then-else语句
                •复杂的条件是否封装成布尔函数调用了？
                •最常见情况放在前面吗？
                •全部情况都覆盖住了吗？
                •if-then-else语句是最好的选择吗？——用case语句代替是否更好？
            case语句
                •各情况的安排次序有含义吗？
                •每种情况对应的操作简单吗？——如需要调用别的子程序。
                •case语句中的变量有实际意义吗？它是为了用case语句而单纯地定义出来的伪变量吗？
                •缺省语句的用法是否合法（规范）？
                •用缺省语句检查和报告异常情况吗？
                •在C语言中，每一情况的结尾用了break了吗？
        ```
    ##### 单元小结
    - 注意if和else的顺序，特别是在处理好多异常情况时，务必使正常情况流向清晰。
    - 组织好if-then-else和case语句中的几种情况，使可读性最好。
    - 在case语句中用缺省值，在if-then-else中的最后一个else中获取意外错误。
    - 各种控制结构并不都同样有用，在编码时选用最合适的控制结构。
---

* 第十五章 循环语句
    1. 选择循环类型
        - 概述
        ```
            使用循环是用程序化语言编程时最复杂的情形之一，知道如何及何时用哪种循环是编写高质量软件的决定性因素。
            在大多数语言中，你总可以用上几种循环类型。
            计数循环要执行给定的循环次数,也可能就只循环一次。
            条件循环事先并不知道要执行多少次循环，而要在每次重复之前检查是否满足循环条件。只要满足循环条件，循环不断继续下去，除非用户退出循环或出错。
            死循环只要开始便无限执行下去。在心脏起搏器、微波炉、巡航控制等系统中，把死循环置入其中。
        ```
        - while循环
        ```
            虽然while循环不全是条件循环，但一般把它看成是条件循环。假如事先你并不知道循环的次数，那就用while循环。注意退出循环的时机。
        ```
        - for循环
        ```
            当你想使程序块循环给定次数时，for循环是一个好的选择。每种循环都应该注重退出逻辑。
        ```
    2. 控制循环
        - 概述
        ```
            在编写循环时会出哪些错？当然包括以下错误：
            忽略了与循环有关的变量或累加器初始化、不正确的嵌套、不正确的循环中断、忘记给循环变量一个增量或给错了增量、用不正确的循环指标访问数组元素。
        ```
        - 进入循环
        ```
            下面几条告诉你如何进入循环：
                1. 仅从一个入口进入循环。
                许多循环控制结构允许你从开头中间或末尾进入循环。你从循环头部进入循环，大可不必多口进入。
                2. 把初始化循环的代码紧放在循环前头。
                3. 把与循环体相关的初始化循环的语句放在一起。
        ```
        - 处理好循环体
        ```
            以下几点对处理好循环体会有帮助：
                1. 用begin和end或｛和｝把循环体括起来。现代语言基本都是括号括起来
                2. 尽量避免用空循环。
                3. 把循环的“内务处理“工作放在循环的开头或结尾。即循环时业务不相关的如： i++ 等操作
                4. 使每个循环仅执行一项功能。
        ```
        - 退出循环
        ```
            以下几点对如何退出循环会有帮助：
                1. 确保循环能终止。
                2. 使循环的终止条件明显。
                3. 循环中不要强制改变控制循环变量从而达到提前终止循环的目的。
                4. 尽量避免直接用到循环控制变量的终值。
                5. 考虑用安全计数器。
        ```
        - 用break和continue语句
        ```
            1. 用break和continue一定要谨慎。
            2. 有选择性地用break语句。 （比如查找列表某个符合条件的值，找到之后即可结束循环，剩余循环没必要执行）
            3. 要特别小心一个循环中许多break语句分散出现的情形。
        ```
        - 检查循环边界
        ```
            一个简单的循环通常要注意三种情况：初始情况、中间情况、结束情况。
        ```
        - 使用循环控制变量
        ```
            1. 在循环和数组中，只能用整数。
            2. 要用有意义的变量名使得循环嵌套易读。
            3. 用有意义的变量名以避免循环变量用重复了。
        ```
        - 一个循环该有多长
        ```
            1. 使循环尽可能短，能一目了然。
            2. 限制嵌套超过3层。
            3. 使长循环显得很清楚。
            越长越复杂。如果你的循环较短，则可以大胆地用break和continue之类的控制结构及多重出口、复杂控制终止条件等等；
            若你的循环较长，从考虑读者的方便起见，你的循环应当是单出口，且终止条件应当是明白无误的。
        ```
    3. 检查表
        - 循环
        ```
            循环是从顶部进入的吗？
            循环的初始化是靠近着循环顶部的吗？
            循环是死循环还是事件驱动循环？它的结构比诸如for i := 1 to 9999之类的更清楚吗？
            是C的for循环吗？
            循环头包含了全部的循环控制条件了吗？
            循环体用begin和end或类似的结构去标明以免在修改时出错了吗？
            空循环还是非空循环？
            把循环内务处理归结到一起了吗？放在头部还是放在结尾了？
            循环是完成一个且仅完成一个功能吗？（像一个子程序一样）
            循环在所有可能情况下都能退出吗？
            循环的中止条件明显吗？
            如果是for循环，在循环体内有没有改变控制变量而使循环强行退出？
            循环体内部用一个变量保留重要循环控制变量的值，而不在循环体外引用控制变量的终值吗？
            循环用了安全计数器了吗？
            循环控制变量是整数类型吗？
            循环控制变量是否有一个有含义的名字？
            避免了控制变量的冲突没有？
            循环短到可一目了然地步了吗？
        ```
    ##### 单元小结
    - 循环很复杂，使其简化有利于阅读。
    - 简化循环的技巧有：避免使用怪样子循环、使循环次数最小、使进出口清楚、把内务代码放在一个地方。
    - 循环控制变量不可滥用，应给它起一个有含义的名字并让它只起一个用途。
    - 仔细考虑一下整个循环，保证循环在各种情况和终止条件下都能照常运行。
---

* 第十六章 少见的控制结构
    1. 讨论范围
    ```
        goto语句
        return语句
        递归调用
    ```
    2. 检查表
        - 少见的控制结构
        ```
            goto
                goto是最后的选择吗？用goto使程序更好读更好维护吗？
                用goto是为效率的目的吗？
                用goto达到此目的了吗？
                一个程序是否只用一个goto呢？
                goto只转向前面的程序段而不是转向其后面的程序段吗？(后面指已执行过程序)
                goto所转向的标号都有了吗？
            return
                每个子程序的return数目是否最少？
                return增强了可读性了吗？
        ```
        - 递归调用
        ```
            用递归调用的代码含使递归结束的语句吗？
            程序设置了安全计数器来保证递归调用终止了吗？
            是否只在一个程序中用递归调用？
            递归调用的深度是否限制在程序堆栈容量可满足的条件下?
            递归调用是实现程序的最优途径吗？它比循环更简单吗？
        ```
    ##### 单元小结
    - 有些情况下，goto是编出易读易维护程序的最好方法。
    - 多重return有时增强了程序的可读性与可维护性，并且防止多重嵌套逻辑，但没必要只想到怎样用好return。
    - 在问题较简单时，递归调用能把问题很巧妙解决。要慎用递归调用。
---

* 第十七章 常见的控制问题
    1. 布尔表达式
        - 概述
        ```
            用True和False作为布尔变量
                用True和False(真和假)作为布尔表达式结果的标识符，而不要用0和1。
                像Pascal之类的语言有布尔型变量来支持定义True和False作为标识符。
                要弄清楚，对布尔型变量，你还只能用True和False来给它赋值而不能用其它的，
                对那些没有布尔型变量的语言，你需用一些规则来使布尔表达式易读。
            使复杂的表达式简单些
                采用以下几步来简化表达式：
                1. 把复杂的测试条件用中间的布尔变量变成几个部分。
                宁愿定义几个奇怪的中间变量并给它们赋值，这样可编写简单的测试条件。
                2. 把复杂的表达式写成一个布尔型函数。
                3. 用决策表代替复杂的条件。
            编写肯定形式的布尔型表达式
                不少人对较长的否定形式的表达式理解起来很困难。也就是说大多数人对否定太多的句子来困难。
                为避免出现复杂的否定形式布尔型表达式，你可依从以下几点：
                1. 在if语句中，把条件从否定形式转化为肯定形式，再把if和else语句后跟着的代码对换。
            用括号使布尔型表达式清晰
                如果布尔型表达式较复杂，用括号使表达式意思更明晰，而不能仅依靠语言运算的顺序。
            了解布尔型变量是怎样运算的
                许多语言隐含着一种怎样运算布尔型变量的规则，有些语言中，编译程序先计算各分量的值，
                然后合起计算整个式子的值，另一些语言中编译程序采用“短路”或“懒惰”算法，即只计算所需部分的值。
                编码中应该确保逻辑解析顺序与意图相符，加括号来保证，即使是数值计算也应该注意
        ```
    2. 防止危险的深层嵌套
        - 概述
        ```
            1. 通过重新编写部分测试条件来简化嵌套的If语句。即拆分
            2. 把if嵌套改成case语句。
            3. 把深层嵌套的代码写成一个子程序。
            4. 重新设计深层嵌套代码。
            一般说来，复杂代码表明还没有完全理解你的程序，应使其更简单些。
            深层嵌套提示需把某些部分写成一个子程序或需重新设计复杂的那部分程序。
            这虽然并不意味着就需要去修改程序，但若无充分理由，还是要修改。
        ```
    3. 结构化编程的作用
        - 概述
        ```
            结构化编程是什么意思？结构化编程的核心基于这样一种简单思想，即程序总是单入单出的结构，
            即程序只能从一个地方开始且也只能从一个地方退出的代码块，没有其它的进口与出口。

            1. 结构化编程的好处
            可读性，可维护性，程序质量
            2. 结构化编程设计的三个组成部分
                顺序编程 
                一个顺序程序指一组按顺序执行的语句。典型的顺序语句包括赋值和子程序调用。
                选择
                选择是一种控制结构。这种结构使语句有选择地被执行。
                重复
                重复也是一种控制结构，它使一组语句被多次执行。循环
        ```
    4. 控制结构和复杂性
        - 概述
        ```
            注意控制结构的一个原因是，它们对于克服程序的复杂性有很大贡献。
            不用控制结构，会增加程序的复杂性。用得好则能降低复杂性。

            1. 程序复杂性的重要性
            计算机科学起码在二十年前就注意到了程序复杂性的重要了。二十年前，Edager Dijkstra就意识到复杂性的危险，
            他说：“一个聪明的程序员总是清楚地知道自己的脑力容量有限，因此他得十分小心谨慎地完成编程任务”（1972）。
            这并不意味着为了处理很复杂的问题你得增大你的脑力，而是说你得想办法尽可能降低复杂性。
            2. 减少复杂性的常用方法
            下面两种方法可以帮助降低程序复杂性。首先，你可以做一些动脑筋练习来提高在脑中打底稿的能力。
            但大多数程序都很大，而人同时考虑的问题一般都不能超过5～9个，因此靠提高脑子的容量来帮助降低复杂性能力有限，
            第二，要降低程序的复杂性就要求你彻底理解你所要解决的问题。
            3. 
        ```
    5. 检查表
        - 控制结构方面
        ```
            表达式用True和False而非1和0？
            布尔型表达式的值是否隐含地与False比较？
            是否通过定义中间布尔型变量和布尔型函数及用决策表的方法来简化表达式？
            布尔型表达式是用肯定形式写出来的吗？
            在C中，数值、字符，指针是显式与0比较的吗？
            begin和end能保持平衡吗？
            为了使程序看起清楚，需要的地方用begin和end对标明了吗？
            空语句看起来清楚吗？
            通过诸如重新组合测试条件、转化为if-then－else或case语句或把嵌套内代码写成子程序的方法来简化嵌套语句了吗？
            如果程序的决定点数超过10，有什么正常理由不重新设计它吗？
        ```
    ##### 单元小结
    - 使布尔型表达式简单可读性高对代码的质量很有好处。
    - 深层嵌套使程序难懂，不过可用相对简单方法避免这样做。
    - 结构化编程是一个简化程序的思想，用顺序编程、选择或循环中的一种或几种方法的组合可编出任何程序。
    - 作这种简化程序的思想可提高程序的产量和质量。
    - 如果所用语言不支持结构化结构，你能模仿它们。你应该把程序编成某种语言的程序而不是用某种语言编程的。
    - 降低复杂性是编写高质量的代码的关键。
---

* 第十八章 布局和风格
    1. 检查表
        - 布局简述
        ```
            大多数现代编程工具都有格式化代码的功能。

            格式化的本意是要显示代码的逻辑结构吗？
            格式化的形式能始终一致吗？
            格式化后使代码易于维护吗？
            格式化后改进了可读性吗？
        ```
        - 控制结构
        ```
            begin－end对中代码避免再次缩排了吗？
            一系列的块结构用空行相互分隔了吗？
            复杂的表达式格式化后可读性增强了吗？
            单条语句块始终一致地格式化了吗？
            Case语句的格式化与其它控制结构格式化相协调吗？
            goto语句格式化后自己显得更清楚了吗？
        ```
        - 单条语句
        ```
            把单条语句分成几行，每行都明显地不能作独立行看待了吗？
            续行有意识地退格了吗？
            相关语句组对齐了吗？
            不相关语句组不应对齐，你是这样的吗？
            每行至多含一条语句吗？
            每个语句避免副作用了吗？
            数据定义时相应项对齐了吗？
            每行至多定义一个数据，是吗？
        ```
        - 注释
        ```
            注释行与它所对应的代码退同样格数了吗？
            注释行的形式易修改吗？
        ```
        - 子程序
        ```
            子程序的参量格式化后各参数易读、易修改、易加注释吗？
            在C中是否用新子程序定义方法呢？
            Fortran中，参数定义是否和局部变量定义分开？
        ```
        - 文件、模块和程序
        ```
            若语言允许有多个源文件，每个源文件仅含一个模块是吗？
            一个文件内的各子程序是否用空行清楚隔开？
            如果一个文件含几个模块，那么每个模块中的子程序是否被组织到被清楚隔开？
            各子程序是否按字母顺序排列？
        ```
    ##### 单元小结
    - 布局首先考虑的是去显示程序的逻辑结构。评价这种考虑是否达到目的标准有：准确性、连续性、可读性、易维护性。
    好看是第二条标准——比较弱的标准。如果以上几条标准都达到了而且程序也较好看，那么布局一般就成功了。
    - 结构化代码是有其自身目的的，你最好还是用一些约定俗成的布局形式而少来创新，以保持与别人协调一致。若你的布局形式与约定的不一样，那么很有可能影响你程序的可读性。
    - 有关部局的好多观点纯属一个信仰或者说个人喜欢问题，努力把客观需要和主观喜好分开。遵从一些明显地规划，以选择你所喜欢的布局形式。
---

* 第十九章 文档
    1. 外部文档
        - 概述
        ```
            软件工程中的文档既包含源码表的内部信息，又包含源码表的外部信息。通常的形式有单独的文件或者综合资料。
            大体上，正式软件工程中大多数文档都位于源码外部。实际上，大约一项大工程全部力量的三分之二放在了创建文档上，而不是源代码上。
            这和输出相似。外部结构文档要在高层上同编码相联系，在低层上和编制前的阶段文件相联系。
        ```
        - 综合资料。
        ```
            一个综合资料，或者软件开发资料是一个非正式文档，它包含着供开发者在编程中使用的记录。
            “综合”广义地讲，通常指是常规的或是特殊的资料。综合资料的主要目的是提供一套其它地方没有描述的设计规则。
            很多软件工程中，有指定最少资料的标准。例如：相关需求的备份、开发标准的备份等。当前编码和综合资料的设计规则，通常都仅用于内部。
        ```
        - 详细设计文档。
        ```
            详细设计文档是低层设计的文档。它描述模块层或程序层的决定，所考虑的选择对象、所选用办法的原因。
            有时这些信息包含在一个正式文档中。这种情况下，详细设计和结构是不同的，有时它主要包含收集在“资料”中开发者的记录。
            有时——常常——它仅存在于编码本身当中。
        ```
    2. 编程风格作文档
        - 概述
        ```
            和外部文档相比，内部文档可见于程序内部。它是最详细的一种文档。由于内部文档和编码联系最密切，故也是当编码被修正后最可能保持正确的那种文档。
            对编码层文档的主要贡献不是注释，而是好的程序风格。风格包含好的程序结构，直接使用和易于理解的方法、好的变量名、好的子程序名、命名常量、清晰的布局和最小的控制流及灵活的数据结构。
        ```
    3. 检查表
        - 子程序
        ```
            每一个子程序名都确切地描述了要做什么事吗？
            每一个子程序详细定义任务吗？
            程序会从它们的子程序中获益吗？
            每个子程序的接口处明确吗？
        ```
        - 数据名称
        ```
            类型名的描述足以帮助文件数据说明吗？
            变量名好吗？
            变量仅用于命名这个目的吗？
            循环计算变量能给出更多的信息吗？
            用枚举类型变量来代替标记或逻辑变量了吗？
            命名常量没有用来代替数字或字串吗？
            类型名、枚举类型名、命名常量、局部变量、模块变量和全局变量中的命名规则不同吗？
        ```
        - 数据组织
        ```
            附加变量在需要时要清零吗？
            变量的引用彼此间很接近吗？
            数据结构简化会导致降低其灵活性吗？
            复杂的数据存取是通过子程序来完成的吗？
        ```
        - 控制
        ```
            正常编码路径清晰吗？
            相关语句分成一组了吗？
            相对独立的语句都组成子程序了吗？
            正常情况跟在IF后，而不是ELSE后吗？
            控制结构简化会降低灵活性吗？
            像一个定义完好的子程序那样，每个循环执行一个且仅一个功能吗？
            嵌套层次是最少吗？
            逻辑表达式用附加的逻辑变量、逻辑函数和功能表简化了吗？
        ```
        - 布局
        ```
            程序布局显示出它的逻辑结构吗？
        ```
        - 设计
        ```
            代码直观吗？它的编写巧妙吗？
            实现细节可能隐去了吗？
            程序编写是立足于问题域而不是计算机科学或语言结构域吗？
        ```
    4. 检查表 有效的注释技术
        - 通用部分
        ```
            代码中是否包含了关于程序的大部分信息？
            是否可以做到随意拿出一段代码便可以立刻理解它的意思？
            注释是否注释了程序的意图或总结了程序的功用而不是简单地重复代码？
            是否使用了PDL——代码流程以减少注释时间？
            对使人困惑的代码是否进行了重写而不是注释？
            注释是否已经过时了？
            注释是清楚正确的吗？
            注释风格是否使得注释很容易修改？
        ```
        - 语句和段落
        ```
            是否避免了结束行注释？
            注释的重点是“为什么”而不是“是什么”吗？
            注释是否提示了后续代码？
            每个注释都是合理的吗？是否删掉或改进了冗余、自相矛盾的注释？
            是否注释了令人惊异的代码？
            是否避免了缩写？
            主要和次要注释间的区别明显吗？
            用于错误处理或未说明功能的代码注释了吗？
        ```
        - 数据说明
        ```
            数据说明单元注释了吗？
            数值数据的取值范围注释了吗？
            是否注释了代码的含义？
            对输入数据的限制注释了吗？
            是否在位层次上对标志进行了注释？
            是否在说明全局数据的地方对其进行了注释？
            常数值是否被注释了？或者被用命名常量代替了吗？
        ```
        - 控制结构
        ```
            每一个控制语句都进行注释了吗？
            冗长或复杂的控制结构进行注释了吗？
        ```
        - 子程序
        ```
            对每个子程序的功用都作出注释了吗？
            在需要时，是否对关于子程序的其它信息进行了注释？包括输入／输出数据、接口假定、错误修正、算法来源、全局效果等？
        ```
        - 文件、模块和程序
        ```
            程序中是否有关于程序总体组织方式的简短注释？
            对每个文件的功用都进行描述了吗？
            注释块中有作者姓名和电话号码吗？
        ```
    ##### 单元小结
    - 是否注释就像是立法。注释得好，是非常值得的，注释得不好，则是浪费时间而且有害。
    - 源代码中应含有关于程序的绝大部分重要信息。只要程序还在运行，那么代码中的注释便不会丢失或被丢弃。把重要信息加入代码是非常重要的。
    - 好的注释是在意愿层次上进行的，它们解释的是“为什么”而不是“是什么”。
    - 注释应表达出代码本身表达不了的意思。好的代码应是自说明的。当你对代码进行注释时，应问一下自己“如何改进代码以使得对其注释是多余的？”，改进代码再加注释以使它更清楚。
---

* 第二十章 编程工具
    ##### 单元小结
    - 好的工具使编程更容易。
    - 你可以编写大多数你需要的工具。
    - 用今天的技术水平能编出高水平的编程工具。
---

* 第二十一章 项目大小如何影响创建
    1. 项目大小对开发活动的影响
        - 概述
        ```
            如果只有你一人开发项目，对项目成功或失败影响最大的正是你自己。如果你所在项目开发组有25人，
            你也可能仍发挥最大作用，但更可能是大家各有一份功劳，整个集体对项目的成功或失败有更大的影响。
        ```
        - 交流和大小
        ```
            简化交流的典型方法是规范化交流方法。不是让50个人按各种可能方式相互间进行交流，
            而是让50个人都阅读和编写文档，有些是文本的，而有些则是图形的，有些是打印在纸上的，或是表格形式的。
        ```
        - 活动比例和大小
        ```
            不论项目的大小如何，以下方法总是有价值的：结构化编码。其它程序员对逻辑和代码的检查、联机开发系统和高级语言的使用，
            对于本项目，这些方法可能并不充分，但是对小项目却是适用的。
        ```
    2. 项目大小对错误的影响
        - 概述
        ```
            质量和错误都要受到项目大小的影响。你可能认为这种类型的错误将不受影响，但是随着项目的变大，相当大的一部分错误通常要归于分析和设计错误。
        ```
    3. 项目大小对生产效率的影响
    ```
        当和项目大小联系在一起时，生产效率和软件质量有许多共同之处。对于小项目（200行或更小），
        对生产效率影响最大的是单个程序员的技巧。随着项目的增大，开发组人数和组织对生产效率影响迅速增大。

        生产效率实际上是由以下因素所决定：人员的素质、编程语言、方法、产品复杂性、编程环境、工具支持和其它许多因素所决定的
    ```
    ##### 单元小结
    - 在一些小项目中的活动并不能想当然地用于大项目中，你应仔细计划它们。随着项目增大，创建作用减弱。
    - 随着项目的增大，交流方法应简化。各种方法的使用应因时而异。
    - 在相同条件下，大项目的生产率比小项目低一些。
    - 在相同条件下，大项目的每行错误数比小项目的每行错误数多。
---

* 第二十二章 创建管理
    1. 使用好的代码
        - 概述
        ```
            由于代码是创建的主要输出，所以创建管理的关键问题是养成使用好代码的习惯。
            一般说来，从开始就用标准并不是一个好的方法。程序员倾向于将管理者视为技术层次中的水平较低者，
            甚至认为其差距犹如单细胞生物和冰川世纪灭绝的猛犸像一样大。如果有编程标准的话，程序员可以买一个。
        ```
        - 标准设置的考虑
        ```
            如果你避免使用标准，标准对你也就不那么重要了，可考虑使用标准的替代：灵活的原则，或者采用一些建议而不用原则，或者一些包含最好实际情况的例子。
        ```
        - 方法
        ```
            以下是取得较好代码效果的几个方法。这些方法不应被视为教条的代码标准。
            1. 将二人分在计划的每一部分。
            如果二人不得不各自编码，你应确保至少这二人认为代码能正常运行同时可读。协调二人的开发方法将涉及到指导者和受训者的配合。
            2. 注释每一行代码。
            一条代码注释常包括程序员和至少两个注释者，这意味着至少有三人将阅读代码的每一行。
            同级注释的另一个名字是“同级压力”。除了防止程序员离开计划体系外，让程序员知道另外一些人还将阅读本代码，将会提高代码质量。
            即使你所在部门没有明确的代码标准，注释也将会提供一个较好的途径，使代码向一个代码标准的方向发展，
            这些标准是群体在注释过程中所得到的一些结论，而且，随着时间的推移，群体将派生出自己的标准。
            注释只在需要的地方,代码语意化更重要
            3. 采用代码许可。
            在一些领域中，技术草图将由管理工程师批准和鉴署。鉴名就意味着对管理工程师来说，本草图在技术上是可行的，
            而且是没有错误的，一些公司也采用这种方法。在代码将完成之前，高级技术主管将签署代码表。
            4. 用好的注释作示例。
            管理的一个重要方面，就是向你的人员清楚地表达你的意图。其中的一条途径就是让你的程序员见识一些好的代码，或将其在公共场合张贴出来。
            这样作将会提供清楚的代码示例，而这正是你所期望的。同样，一本代码标准手册将包括一些“最好的代码表”，指定一些表作为最好的代码以便其它人能效仿。
            这样一本手册将比一本英语标准手册要容易改进，而且，无须费多大劲就能展示代码风格的精细，如果靠平铺直叙一点一点描述是困难的。
            5. 强调代码表是公用财产。
            程序员有时会觉得代码是“他们的代码”，好像这是其私人财产一样。虽然这是程序员自己心血的结晶，
            但是代码是整个计划的一部分，计划中需要它的人应有权得到它。代码在注释和维护阶段应当被其它人所看到。
            6. 奖赏好的代码。
            用奖励办法促进好的代码开发工作。当你开发你的系统时，请牢记以下几点：
            此奖励应是程序员所需要的（许多程序员发现“哄小孩”似的奖励是令人生厌的，尤其是这些来自那些非技术管理人员的时候）。
            所奖励的代码应是非常好的。如果你奖励一个大家都知道其工作干得不好的程序员，你将收到相反的效果。
            至于程序员是否态度好或是否按时上班则不是重要的。如果你的奖励和相应技术价值不一致，你将失去信誉。
            如果你的技术不够高，不能判断哪一个是好的代码，那么，你就根本无须奖励，或者让你的合作者们选择。
            7. 一个简单的标准。
            如果你管理一个编程计划，同时你也有编程经验的话，做好工作的一个有效的方法是说：“我必须能够阅读和理解本计划所编的所有代码”。
            管理者不是技术尖子，但防止“聪明”或恶作剧式编码也是有好处的。
        ```
    2. 配置管理
        - 概述
        ```
            软件计划是变化：代码在变化、设计在变化、需求在变化，而且需求的变化引起设计上更多的变化，设计上的变化又会引起代码和测试情况的更多变化。
        ```
        - 何调配置管理
        ```
            配置管理是全面地处理各种变化，以便系统随着时间的推移能保证其完整性。其另一个名字是“修改控制”。
            它包括如下各种方法，评估各种建议处理各种修改、在不同的时间保留系统的各种备份。
        ```
        - 软件设计修改
        ```
            在开发过程中，你一定会被怎样改进系统的性能所困扰。如果你只是在每个修改发生时才去考虑它，
            你会发现自己进入了软件开发的歧路——整个系统在变化，离目标的完成也是遥遥无期。
            以下是控制设计修改的几条准则：
            1. 遵循正规修改控制流程。
            正如第三章所指出的那样，正规修改控制流程是你处理许多修改要求的有力手段。建立正规流程，会对如何在整个计划的范围内考虑修改有一个清晰的了解。
            2. 建立修改控制委员会
            修改控制委员会的工作是在有修改请求时，从"米糠”中将“小麦”区分开来。任何想修改的人，将变化请求提交给变化控制委员会
            3. 集成考虑修改请求。
            个非正式的解决这个问题的方法是写下所有的主意和建议，而不管完成它的难易程度如何，同时也应及时保留这些建议和主意直到你有时间去处理它们。
            最终，将其作为一个整体看待，选择其中最有实效的一个。
            4. 估计改变所花的代价。
            5. 谨慎对待主要修改。
            如果顾客建议进行重大修改，这是对你的工作没有满足要求的警告。
            如果在代码开发过程中，你的顾客坚持要作重大修改，你应坐下来和你的顾客谈一谈，
            并指出它对已经进行的工作所产生的影响。其中一个明显的影响就是早期的一些工作将废弃。
        ```
        - 软件代码改变
        ```
            另外一个配置管理主题是控制源代码。
            1. 版本控制软件。
            一些版本控制软件工作起来是如此地得心应手以致于你很少注意到你正在使用它。
        ```
        - 备份计划
        ```
            你应采用一些措施以便确保你的工作成果。你的备份计划应当包括定期进行备份，
            定期将备份转移至安全处，除了源代码以外，还应包括项目所有的重要资料、文档、图形、注释。
        ```
        - 检查表 
        ```
            配置管理
                一般
                你的软件配置管理计划是否用于帮助程序员，并能将额外开销减至最少？
                你使用SCM手段能否避免对项目失控？
                你所在组是否有修改请求？请示控制可以是非正式方式或正式的方式。
                你是否能比较正确地估计每次修改的影响？
                你是否将重要修改视为需求分析不充分的警告？
                工具
                你是否使用版本控制软件以便配置管理？
                你是否使用版本控制软件以减少开发时的协调问题？
                你是否使用制作或其它控制依赖软件使编程更为有效和可靠？
                备份
                你是否将所有项目材料定期备份？
                你是否定期将所有项目备份移到安全地点存放？
                包括源代码、文档、图形和重要注释在内的所有材料都备份了吗？
                你是否对备份程序进行了测试？
        ```
    3. 评估创建计划
        - 概述
        ```
            软件工程管理是二十世纪晚期对人类来说不可轻视的挑战之一。评估工程的大小和完成时间是软件工程管理最为棘手的问题之一。
            一般的大软件工程完成需一年多时间，同时所需费用也可能会超出预算的100％（Jones1986）。
            这主要是由于对工程的大小和所需时间估计有误和开发过程不努力有关。本节讨论如何评估软件工程，并阐明如何获得更多的信息。
        ```
        - 评估方法
        ```
            1. 评估对象。
            你在评估什么？你为何要评估？你的对象需多大的评估精度？评估需多大确定性？乐观和悲观的评估到底能有何差别？
            2. 使评估有充足时间并计划评估。
            匆忙评估是不精确的。如果你要评估一个大的软件工程，你应将评估视为一个小的项目，并花费时间去评估时间。
            3. 不要草率估计软件工程的各种开销。
            在某事物还没有被定义前，别人让你去估计产生它需要多少工作量是不明智的。在作出估计之前应定义要求，或对初始探索阶段进行计划。
            4. 对你所需判别的对象从层次细节上进行评估。
            从对项目活动的各细节上进行评估，一般说来，你的检查越详细，你的评估就越难确
            5. 使用不同的评估方法并比较其结果。
            6. 定期再评估。
            软件工程的各种因素在评估后都会有所变化，所以你应对定期再评估有所计划。
        ```
        - 评估创建工作量
        ```
            对完成一个项目需要多少创建的最佳回答随项目和组织的不同各项分配有所不同。你在开发项目过程中，应当利用你过去的工作经验来估计项目所需花费的时间。
        ```
        - 项目进度的影响因素
        ```
            协作动机
            管理质量
            代码再利用量
            人事变动
            语言水平
            需求变更
            和客户的关系如何
            用户对要求的参与程度
            用户的应用经验
            什么范围内的程序员参与需求分析
            对计算机、程序、数据的安全确保体系
            文档量大小
            项目对象（进度表、质量、可用性和其它可能对象）
        ```
        - 评估和控制
        ```
            重要问题是：你是想要预测，还是想要控制？
            评估是使软件工程按时完成计划的重要组成部分。一旦你确定了交货日期和产品性能，剩下的主要问题是怎样控制人力和技术资源的开销，
            以便能按时交付产品。从此种意义上来讲，成功地利用各种资源以满足计划要求，比初始估计的准确性更为重要。
        ```
        - 如果你落后了怎么办
        ```
            很多软件开发进度落后于预定要求，对一些实际软件开发的调查结果表明，评估所需时间要比实际所用时间少20～30％。
            1. 努力赶上。
            当项目进度落后时，通常的反应是对此抱有乐观态度。较为理智的想法是这样：
            “所用时间比我们所预期的要长一点，但如今这是不可变更的，我们以后能挽回这点时间”
            2. 扩大队伍人数。
            对一个已经落后于预定时间的软件工程，增加人数只会使其更加落后。这好比向火上添油。
            这种解释是颇有说服力的，在新手能富有成效地工作之前，他们需要有一段时间熟悉工作。
            对他们进行培训浪费了已受训人员的时间。而且增加人数也增加了软件开发的复杂性和相互间的通信量。

            最好是项目初期的评估就需要较为准确的评估项目所需各项资源
        ```
    4. 将程序员视为普通人
    5. 如何对待上司
        - 简述
        ```
            在软件开发过程中，非技术人员往往是管理者。最为例外的情况是管理者有工作经验，但是已是十年未再干过了。
            会技术的管理者是少见的。如果你为某一人工作，应尽力保住你的饭碗。这不是一件容易的事情。
            作为一个阶层，每一位雇员都想升到他并不能胜任的层次。

            如果你的上司并不是一个特别的人，你将不得不学会如何面对你的上司。“控制你的上司”意味着你应告诉你的上司怎样去做，
            而不是用其他方法。其要决在于用这样一种方法使你的上司相信你仍是受他管理的一员。以下是一些对付你上司的方法：
                拒绝按照你上司的吩咐去做，坚持按正确方法继续你的工作。
                假装按照你上司的吩咐去做，暗地里按照正确的方法去做。
                先对自己如何做有一个全盘计划，等着上司对你的见解做评论并让人如何去做。
                告诉你上司正确的方法，这是一个中途应变方法，因为你的上司经常提升、调动或被解雇。
                寻找另一份工作。
                最好的解决方法是努力说服你的上司。这并不是一件容易的事情
        ```
    ##### 单元小结
    - 配置管理，适当应用时，可使程序的工作变得更容易进行。
    - 你能找到某种方法度量项目的某一方面，这样比根本不度量好。准确的度量是完善的计划、质量控制和提高开发速度的关键。
    - 程序员和管理者都是普通的人，当他们受到礼待时往往干得更好。
    - 合适的软件工程评估是软件开发管理最富挑战性的方面，你不妨尝试几种方法，看看评估的差别，以加深你对项目的认识。
---

* 第二十三章 软件质量概述
    1. 软件质量特点
        - 概述
        ```
            软件既有外部也有内部质量特征。软件的外部特征是用户应了解的软件产品属性，它包括：
                正确性。
                    整个系统受说明、设计和实现的错误影响程度。
                    可用性。用户学会和使用系统的难易程度。
                    效率。对系统资源的最小利用，包括存储和执行时间。
                    可靠性。系统在一定条件下执行特定功能的能力—在每次失效之间有一个较长的平均时间。
                    完整性。防止非法或不适当地访问。
                    完整性思想包括：限制非法用户访问，同时确保
                    证数据恰当访问；并行数据表进行并行修改；数据段仅含有有效数据等等。
                    适应性。系统在应用或其它环境下不作修改就能使用的能力，而不必经过特定的设计。
                    精确性。系统不受错误影响的程度，尤其是数据输出方面。精确性和正确性是不同的。
                    精确性是对系统完成其工作性能良好的衡量，而不是它设计得是否正确。
                    坚固性。系统对无效输入或压力环境中能继续执行其功能的能力。

            外部特征是用户所关心的特征。用户常关心软件是否易使用，而不是是否容易修改。他们也关心软件是否能正确工作，而不是代码是否可读或结构较好。
            但是，程序员既关心内部特征也关心外部特征。本书着重讨论代码，所以着重于内部特征，其包括：
                可维护性。修改一个软件系统，提高其性能或修正其错误的能力。
                灵活性。修改系统使其能适应于不同的用途或环境的能力，而不必对系统进行特定的设计。
                可移植性。能修改所设计的某一系统使其能在其它环境下运行的能力。
                可重用性。能将系统的一部分用于其它系统的难易程度。
                可读性。能读懂或理解系统源代码的能力，尤其是在细节说明这一级上。
                可测试性。对整个系统进行单元或系统测试以证实其满足所有需求性能的测试难易程度。
                可理解性。能从整个系统水平或细节说明这一级上理解整个系统的难易程度。可理解性要比可读性从更一般的水平上讨论系统的紧密性。
        ```
    2. 提高软件质量的方法
        - 概述
        ```
            软件质量保证，是保证系统满足性能要求的有计划、有组织的活动。开发高质量产品的最为有效的方法是提高产品本身的质量。
            软件质量保证最好的方法是控制软件的开发过程。以下是关于软件质量管理计划的组成部分：
                1. 质量管理目标。
                提高软件质量一个有效方法，是从上节所讨论过的外部和内部特征中挑选出明确的目标。没有明确的目标，程序员就可能着重于并不是你所要求的特性。
                2. 确定质量保证活动。
                对质量保证的一般看法是将质量视为一个目标。的确，在一些组织中，急促和草率的编程往往是一件常见的事。
                程序代码充满错误但能很快完成编程的程序员往往能得到更多的奖励。而高质量的程序员。
                虽然编出的程序优秀而且确保其是可用的，却往往得不到这种礼遇。在这样的组织中，人们也就不会对程序员不再把编程质量放在首位而惊讶了。
                所以应该让程序员明白质量是第一的。进行独立的质量保证活动使这种重要性得以体现出来，而程序员也能作出相应的反应。
                3. 测试策略。
                执行时间可以作为对产品可靠性的估计。开发者往往将调试作为质量评估和质量提高的主要手段。
                4. 软件工程准则。
                5. 非正式技术检查。
                许多软件开发者在将工作送交正式检查之前，往往先要对其进行非正式检查。非正规检查包括手工检查设计、代码或对整个代码普查一下。
                6. 正规技术检查。
                软件开发管理是在最低级阶段发现问题，即在问题花费最少的阶段发现问题。
                为了实现此目标，软件工程开发者常使用“质量门——（qualitygate）定期的检查以确定某阶段的产品质量是否达到了继续下一步的要求。
                质量门常在需求分析和结构、结构和详细设计、详细设计和编码、编码和测试之间使用。质量门可以是普查、客户检查等检查。
                7. 外部检查。
                外部检查是一种特定类型的技术检查，以决定项目的状态或正在开发之中的软件质量。检查组来自外部并将其调查结果交给委托者，通常是你的上司。
                8. 开发过程。
                以上所提的各部分和软件质量有明确的关系，而与软件开发过程有着暗含的关系。
                含质量保证活动的开发过程将比不含质量保证活动的过程会开发出更好的软件。
                其它不和软件质量有明显关系的活动也将会影响软件的质量。
                9. 修改控制过程。
                妨碍软件质量的一个障碍是失控的修改。失控的修改会导致编码和设计的毁坏。
                结构或设计上的失控修改会导致代码和设计不一致。而修改代码以适应新的设计将比按预定计划需要更多的时间。
                10. 结果的定量。
                质量确保计划应是可衡量的，否则你无法清楚计划是否产生了效果。
                度量告诉你计划的成功或失败，也允许你对进度作出一定的修改，以看看进度是否有所加快。
                11. 原型。
                原型是对系统关键功能的可实现模块的开发。开发者应将用户界面部分地原型化以确定可用性，同时进行计算以决定执行时间，
                以及数据安排所应满足的存储要求。对16个发表的和8个未发表的用例调查，将原型和传统的规范开发方式相比较。
                这比较提示了原型可导致更好的设计、更好地满足用户需求，以及提高可维护性。
        ```
        - 设置目标
        ```
            明确地设置质量目标是确保软件质量一个有效的步骤，但是它易被忽略掉。
            你可能怀疑如果当你设置明确的质量目标之后，程序员们能否实现它们？回答是他们实现了的，只要他们知道目标并且目标本身也是合理的。
            如果目标经常改变或根本不可能实现，程序员对目标是会无动于衷的。
        ```
    3. 各种方法的效果
        - 修改错误的代价
        ```
            发现错误的代价是总代价的一部分。另一个问题就是修改错误的代价。乍看起来你可能以为修改一个错误应花费相同的代价。
            其实并不是这样，错误留在系统中的时间越长，将其除去所花的代价也越大，能较早发现错误的方法将导致低的错误改正代价。
            以下是关于有效的软件质量程序必须包括的几种技术问题：
                对系统关键部分的正式设计检查
                使用快速原型化技术进行模块化或原型化
                代码阅读或检查
                运行测试
        ```
    4. 何时应作质量保证
        - 概述
        ```
            正如第三章所指出的那样，错误进入软件的时间越早，它就越深藏于软件的其它部分中，也就越不易将其移去。
            一个分析上的错误能在设计上产生一个或多个相应的错误，而这也会导致代码产生许多错误。分析的错误能导致不必要的结构或坏的结构选择。
            多余的结构将导致多余的代码、测试和文档。正如在浇铸地基之前，在设计蓝图上找出各种缺陷一样，在各活动之前找出分析和结构错误不失为一种好方法。

            在软件开发的各个阶段都有可能潜入错误。因此，你在开发过程中，应自始至终强调质量保证工作。
            在工作一开始就应将其作为整个项目计划的一个部分。而且，质量保证工作也应坚持到项目结束为止，这样才能最后确保产品的质量。
        ```
    5. 软件质量的一般原则
        - 概述
        ```
            如同没有免费午饭，或者即使有也不能保证其质量较好一样。软件开发和烹饪是全然不同的事情，
            而且从某种意义上看，软件质量是不一般的。软件质量的一般原则是提高其质量并少各种花费。
            要理解此原则应基于对以下事实的理解：提高效率和质量的最好方法是减少代码再加工的时间，
            不论再加工是由于要求的变更、设计的修改或调试。

            如果不顾质量而只是想用最短的时间将软件开发出来，往往很可能需要较长的时间和花费超出。
            从一开始就着眼于取得最高可能质量和可靠性的软件开发，易于取得最好的开发进度、最高的生产率甚至是最好的市场成功率。
        ```
        - 检查表
        ```
            质量保证步骤
                你是否有项目较为重要的特定质量描述？
                你是否让其它人明白项目的质量目标？
                你是否要求不同的外部和内部特征？
                你是否考虑过某些特性可能和其它相互矛盾或采用共同促进的方式？
                你的项目是否需要几种不同的错误检查方法，以便能发现几种类型的错误？
                你的项目是否包括这样一个计划，以便在软件开发过程中采取措施确保软件质量？
                你的软件质量是否能按某种方式度量，以确定软件质量是提高或下降了？
                你在管理中是否知道质量确保在刚开始可能增加费用，但今后的花费能节省？
        ```
    ##### 单元小结
    - 并不是所有质量保证目标都能实现。确定你想实现的目标，并将其让你所在组的每一个人知道。
    - 各种错误检查方法就其自身来说并不十分有效。仅用一种方法消除错误并非有效。成功的质量确保计划使用几种不同的方法，以确定不同类型的错误。
    - 你可在创建之前或创建过程中使用几种有效的方法以发现错误。你发现错误越早，其所引起的损失也越小。
    - 软件开发领域中的质量保证是面向过程的。软件开发并不包括影响最终产品的重复开发阶段，所以产品开发过程控制着产品的质量。
    - 质量最终是主动的，它要求对系统的资源进行再分配，以便能预防错误而不是花费较大地去提高质量。
---

* 第二十四章 评审
