* 第一章 计算机系统漫游
    1. 总述
    ```
        计算机系统是由硬件和系统软件组成的,它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化,但是系统内在的概念却没有改变。
        所有计算机系统都有相似的硬件和软件组件,它们又执行着相似的功能。一些程序员希望深人了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的,以此来提高自身的技能。
        本书便是为这些读者而写的。
    ```
    2. 信息就是位+上下文
    ```
        源程序实际上就是一个由值0和1组成的位(又称为比特)序列,8个位被组织成一组,称为字节。每个字节表示程序中的某些文本字符。
        大部分的现代计算机系统都使用AScⅡ标准来表示文本字符,这种方式实际上就是用一个唯一的单字节大小的整数值e来表示每个字符。
    ```
    3. 程序被其他程序翻译成不同的格式
    ```
        这个翻译过程可分为四个阶段完成:
        1. 预处理阶段。预处理器(cpp)根据以字符#开头的命令,修改原始的C程序。
        2. 编译阶段。编译器(ccl)将文本文件hello.i翻译咸文本文件hello.s,它包含一个汇编语言程序。
        3. 汇编阶段。接下来,汇编器(as)将he||○.S翻译成机器语言指令,把这些指令打包成一种叫做可重定位目标程.并将结果存入二进制文件.
        4. 链接阶段。请注意,hello程序调用了printf函数,它是每个C编译器都提供的标准C库中的一个函数. 
        printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中,而这个文件必须以某种方式合并到我们的hello.o程序中。
        链接器(1d)就负责处理这种合并。结果就得到hello文件,它是一个可执行目标文件(或者简称为可执行文件),
        可以被加载到内存中,由系统执行。
    ```
    4. 了解编译系统如何工作是大有益处的
    ```
        对于像hello.c这样简单的程序,我们可以依靠编译系统生成正确有效的机器代码。但是,有一些重要的原因促使程序员必须知道编译系统是如何工作的。
        1. 优化程序性能。现代编译器都是成熟的工具,通常可以生成很好的代码。作为程序员,我们无须为了写出高效代码而去了解编译器的内部工作。
        2. 理解链接时出现的错误。
        3. 避兔安全漏洞。多年来,缓冲区溢出错误是造成大多数网络和Intemet服务器上安全漏洞的主要原因。
        存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。
        学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。
    ```
    5. 处理带读并解释储存在内存中的指令
        - 总述
        ```
            此刻,hello.c源程序已经被编译系统翻译成了可执行目标文件hel|o,并被存放在磁盘上。
            要想在Unix系统上运行该可执行文件,我们将它的文件名输人到称为shell的应用程序中:

            sheⅡ是一个命令行解释器,它输出一个提示符,等待输人一个命令行,然后执行这个命令。
            如果该命令行的第一个单词不是一个内置的shell命令,那么shell就会假设这是一个可执行文件的名字,
            它将加载并运行这个文件。所以在此例中,sheⅡ将加载并运行hello程序,然后等待程序终止. 
            hell0程序在屏幕上输出它的消息,然后终止o shell随后输出一个提示符,等待下一个输人的命令行。
        ```
        - 系统的硬件组成
        ```
            1.总线
            贯穿整个系统的是一组电子管道,称作总线,它携带信息字节并负责在各个部件间传递。
            通常总线被设计成传送定长的字节块,也就是字(word)。字中的字节数(即字长)是一个基本的系统参数,各个系统中都不尽相同。
            现在的大多数机器字长要么是4个字节(32位),要么是8个字节(64位)
            2. I/O设备
            Ⅰ/o(输人/输出)设备是系统与外部世界的联系通道。
            我们的示例系统包括四个Ⅰ/o设备:作为用户输人的键盘和鼠标,作为用户输出的显示器,以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘)。
            最开始,可执行程序hello就存放在磁盘上。
            3. 主存
            主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据。
            4. 处理器
            中央处理单元(CPU),简称处理器,是解释(或执行)存储在主存中指令的引擎。
        ```
        - 高速缓存至关重要
        ```
            这个简单的示例揭示了一个重要的间题,即系统花费了大量的时间把信息从一个地方挪到另一个地方.
            hello程序的机器指令最初是存放在磁盘上,当程序加载时,它们被复制到主存;当处理器运行程序时,指令又从主存复制到处理器。
            相似地,数据串“hello,WOr|d/n#开始时在磁盘上,然后被复制到主存,最后从主存上复制到显示设备。
            从程序员的角度来看,这些复制就是开销,减慢了程序“真正”的工作。
            因此,系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

            根据机械原理,较大的存储设备要比较小的存储设备运行得慢,而快速设备的造价远高于同类的低速设备。
            比如说,一个典型系统上的磁盘驱动器可能比主存大1000倍,但是对处理器而言,
            从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍。

            类似地,一个典型的寄存器文件只存储几百字节的信息,而主存里可存放几十亿字节。
            然而,处理器从寄存器文件中读数据比从主存中读取几乎要快100倍。
            更麻烦的是,随着这些年半导体技术的进步,这种处理器与主存之间的差距还在持续增大。
            加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。

            针对这种处理器与主存之间的差异,系统设计者采用了更小更快的存储设备,
            称为高速缓存存储器(cachememory,简称为cache或高速缓存),作为暂时的集结区域,存放处理器近期可能会需要的信息。

            本书得出的重要结论之一就是,意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。
        ```
        - 存储设备形成层次结构
        ```
            
        ```
