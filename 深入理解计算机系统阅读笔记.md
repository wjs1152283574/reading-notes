* 综述 计算机系统漫游
    1. 总述
    ```
        计算机系统是由硬件和系统软件组成的,它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化,但是系统内在的概念却没有改变。
        所有计算机系统都有相似的硬件和软件组件,它们又执行着相似的功能。一些程序员希望深人了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的,以此来提高自身的技能。
        本书便是为这些读者而写的。
    ```
    2. 信息就是位+上下文
    ```
        源程序实际上就是一个由值0和1组成的位(又称为比特)序列,8个位被组织成一组,称为字节。每个字节表示程序中的某些文本字符。
        大部分的现代计算机系统都使用AScⅡ标准来表示文本字符,这种方式实际上就是用一个唯一的单字节大小的整数值e来表示每个字符。
    ```
    3. 程序被其他程序翻译成不同的格式
    ```
        这个翻译过程可分为四个阶段完成:
        1. 预处理阶段。预处理器(cpp)根据以字符#开头的命令,修改原始的C程序。
        2. 编译阶段。编译器(ccl)将文本文件hello.i翻译咸文本文件hello.s,它包含一个汇编语言程序。
        3. 汇编阶段。接下来,汇编器(as)将he||○.S翻译成机器语言指令,把这些指令打包成一种叫做可重定位目标程.并将结果存入二进制文件.
        4. 链接阶段。请注意,hello程序调用了printf函数,它是每个C编译器都提供的标准C库中的一个函数. 
        printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中,而这个文件必须以某种方式合并到我们的hello.o程序中。
        链接器(1d)就负责处理这种合并。结果就得到hello文件,它是一个可执行目标文件(或者简称为可执行文件),
        可以被加载到内存中,由系统执行。
    ```
    4. 了解编译系统如何工作是大有益处的
    ```
        对于像hello.c这样简单的程序,我们可以依靠编译系统生成正确有效的机器代码。但是,有一些重要的原因促使程序员必须知道编译系统是如何工作的。
        1. 优化程序性能。现代编译器都是成熟的工具,通常可以生成很好的代码。作为程序员,我们无须为了写出高效代码而去了解编译器的内部工作。
        2. 理解链接时出现的错误。
        3. 避兔安全漏洞。多年来,缓冲区溢出错误是造成大多数网络和Intemet服务器上安全漏洞的主要原因。
        存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量和格式。
        学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。
    ```
    5. 处理带读并解释储存在内存中的指令
        - 总述
        ```
            此刻,hello.c源程序已经被编译系统翻译成了可执行目标文件hel|o,并被存放在磁盘上。
            要想在Unix系统上运行该可执行文件,我们将它的文件名输人到称为shell的应用程序中:

            sheⅡ是一个命令行解释器,它输出一个提示符,等待输人一个命令行,然后执行这个命令。
            如果该命令行的第一个单词不是一个内置的shell命令,那么shell就会假设这是一个可执行文件的名字,
            它将加载并运行这个文件。所以在此例中,sheⅡ将加载并运行hello程序,然后等待程序终止. 
            hell0程序在屏幕上输出它的消息,然后终止o shell随后输出一个提示符,等待下一个输人的命令行。
        ```
        - 系统的硬件组成
        ```
            1.总线
            贯穿整个系统的是一组电子管道,称作总线,它携带信息字节并负责在各个部件间传递。
            通常总线被设计成传送定长的字节块,也就是字(word)。字中的字节数(即字长)是一个基本的系统参数,各个系统中都不尽相同。
            现在的大多数机器字长要么是4个字节(32位),要么是8个字节(64位)
            2. I/O设备
            Ⅰ/o(输人/输出)设备是系统与外部世界的联系通道。
            我们的示例系统包括四个Ⅰ/o设备:作为用户输人的键盘和鼠标,作为用户输出的显示器,以及用于长期存储数据和程序的磁盘驱动器(简单地说就是磁盘)。
            最开始,可执行程序hello就存放在磁盘上。
            3. 主存
            主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据。
            4. 处理器
            中央处理单元(CPU),简称处理器,是解释(或执行)存储在主存中指令的引擎。
        ```
        - 高速缓存至关重要
        ```
            这个简单的示例揭示了一个重要的间题,即系统花费了大量的时间把信息从一个地方挪到另一个地方.
            hello程序的机器指令最初是存放在磁盘上,当程序加载时,它们被复制到主存;当处理器运行程序时,指令又从主存复制到处理器。
            相似地,数据串“hello,WOr|d/n#开始时在磁盘上,然后被复制到主存,最后从主存上复制到显示设备。
            从程序员的角度来看,这些复制就是开销,减慢了程序“真正”的工作。
            因此,系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

            根据机械原理,较大的存储设备要比较小的存储设备运行得慢,而快速设备的造价远高于同类的低速设备。
            比如说,一个典型系统上的磁盘驱动器可能比主存大1000倍,但是对处理器而言,
            从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍。

            类似地,一个典型的寄存器文件只存储几百字节的信息,而主存里可存放几十亿字节。
            然而,处理器从寄存器文件中读数据比从主存中读取几乎要快100倍。
            更麻烦的是,随着这些年半导体技术的进步,这种处理器与主存之间的差距还在持续增大。
            加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。

            针对这种处理器与主存之间的差异,系统设计者采用了更小更快的存储设备,
            称为高速缓存存储器(cachememory,简称为cache或高速缓存),作为暂时的集结区域,存放处理器近期可能会需要的信息。

            本书得出的重要结论之一就是,意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。
        ```
        - 存储设备形成层次结构
        ```
            在处理器和一个较大较慢的设备(例如主存)之间插人一个更小更快的存储设备(例如高速缓存)的想法已经成为一个普遍的观念。
            实际上,每个计算机系统中的存储设备都被组织成了一个存储器层次结构,在这个层次结构中,从上至下,
            设备的访问速度越来越慢、容量越来越大,并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部,
            也就是第0级或记为LO.这里我们展示的是三层高速缓存Ll到L3,占据存储器层次结构的第1层到第3层。主存在第4层,以此类推。

            存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。
            因此,寄存器文件就是Ll的高速缓存,Ll是L2的高速缓存,L2是L3的高速缓存,L3是主存的高速缓存,而主存又是磁盘的高速缓存。
            在某些具有分布式文件系统的网络系统中,本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

            正如可以运用不同的高速缓存的知识来提高程序性能一样,程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。
        ```
        - 操作系统管理硬件
        ```
            让我们回到hell〇程序的例子。当shell加载和运行hello程序时,以及hello程序输出自已的消息时,
            Shell和hell〇程序都没有直接访问键盘、显示器、磁盘或者主存。
            取而代之的是,它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插人的一层软件,
            所有应用程序对硬件的操作尝试都必须通过操作系统。

            1. 进程
            进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程,
            而每个进程都好像在独占地使用硬件。而并发运行,则是说一个进程的指令和另一个进程的指令是交错执行的。
            在大多数系统中,需要运行的进程数是多于可以运行它们的CPU个数的。
            传统系统在一个时刻只能执行一个程序,而先进的多核处理器同时能够执行多个程序。
            无论是在单核还是多核系统中,一个CPU看上去都像是在并发地执行多个进程,这是通过处理器在进程间切换来实现的。
            操作系统实现这种交错执行的机制称为上下文切换。

            操作系统保持跟踪进程运行所需的所有状态信息。这种状态,也就是上下文,包括许多信息,比如PC和寄存器文件的当前值,以及主存的内容。
            在任何一个时刻,单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时,就会进行上下文切换,
            即保存当前进程的上下文、恢复新进程的上下文,然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。
            2. 线程
            尽管通常我们认为一个进程只有单一的控制流,但是在现代系统中,一个进程实际上可以由多个称为线程的执行单元组成,
            每个线程都运行在进程的上下文中,并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求,
            线程成为越来越重要的编程模型,因为多线程之间比多进程之间更容易共享数据,也因为线程一般来说都比进程更高效。
            当有多处理器可用的时候,多线程也是一种使得程序可以运行得更快的方法
            3. 虚拟内存
            虚拟内存是一个抽象概念,它为每个进程提供了一个假象,即每个进程都在独占地使用主存。
            每个进程看到的内存都是一致的,称为虚拟地址空间。

            每个进程看到的虚拟地址空间由大量准确定义的区构成,每个区都有专门的功能。
            在本书的后续章节你将学到更多有关这些区的知识,但是先简单了解每一个区是非常有益的。
            我们从最低的地址开始,逐步向上介绍。
                1. 程序代码和数据 
                对所有的进程来说,代码是从同一固定地址开始,紧接着的是和C全局变量相对应的数据位置。
                代码和数据区是直接接照可执行目标文件的内容初始化的.
                2.堆
                代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小,
                与此不同,当调用像malloc和free这样的C标准库函数时,堆可以在运行时动态地扩展和收缩
                3.共享库。
                大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。
                4. 栈。
                位于用户虚拟地址空间顶部的是用户栈,编译器用它来实现函数调用。
                和堆一样,用户栈在程序执行期间可以动态地扩展和收缩。
                特别地,每次我们调用一个函数时,栈就会增长;从一个函数返回时,栈就会收缩。
                5. 内核虚拟内存
                地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。
                相反,它们必须调用内核来执行这些操作。

                虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互,包括对处理器生成的每个地址的硬件翻译。
                基本思想是把一个进程虚拟内存的内容存储在磁盘上,然后用主存作为磁盘的高速缓存。
        ```
        - 文件
        ```
            文件就是字节序列,仅此而已。
            文件就是字节序列,仅此而已。每个Ⅰ/o设备,包括磁盘、键盘、显示器,甚至网络,都可以看成是文件。
            系统中的所有输人输出都是通过使用一小组称为UnixI/o的系统函数调用读写文件来实现的。
        ```
    6. 系统之间利用网络通信
    ```
        我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上,现代系统经常通过网络和其他系统连接到一起。
        从一个单独的系统来看,网络可视为一个Ⅰ/o设备。
        当系统从主存复制一串字节到网络适配器时,数据流经过网络到达另一台机器,而不是比如说到达本地磁盘驱动器。
        相似地,系统可以读取从其他机器发送来的数据,并把数据复制到自已的主存.
    ```
    7. 重要主题
        - 总述
        ```
            在此,小结一下我们旋风式的系统漫游。这次讨论得出一个很重要的观点,那就是系统不仅仅只是硬件。
            系统是硬件和系统软件互相交织的集合体,它们必须共同协作以达到运行应用程序的最终目的。
            本书的余下部分会讲述硬件和软件的详细内容,通过了解这些详细内容,你可以写出更快速、更可靠和更安全的程序。
        ```
        - Amdahl定律
        ```
            律的主要观点一要想显著加速整个系统,必须提升全系统中相当大的部分的速度。
            Amdahl定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外,它还可以用在公司试图降低刀片制造成本,
            或学生想要提高自已的绩点平均值等方面。也许它在计算机世界里是最有意义的,
            在这里我们常常把性能提升2倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。
        ```
        - 并发和并行
        ```
            数字计算机的整个历史中,有两个需求是驱动进步的持续动力:一个是我们想要计算机做得更多,
            另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时,这两个因素都会改进。
            我们用的术语并发(concurrency)是一个通用的概念,指一个同时具有多个活动的系统;
            而术语并行(para11elism)指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个抽象层次上运用。
            在此,我们按照系统层次结构中由高到低的顺序重点强调三个层次。
            1. 线程级并发
            构建在进程这个抽象之上,我们能够设计出同时有多个程序执行的系统,这就导致了并发。使用线程,我们甚至能够在一个进程中执行多个控制流。
            多处理器的使用可以从两方面提高系统性能。首先,它减少了在执行多个任务时模拟并发的需要。
            正如前面提到的,即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。
            其次,它可以使应用程序运行得更快,当然,这必须要求程序是以多线程方式来书写的,这些线程可以并行地高效执行。
            2. 指令级并行
            在较低的抽象层次上,现代处理器可以同时执行多条指令的属性称为指令级并行。
            3. 单指令、多数据并行
            在最低层次上,许多现代处理器拥有特殊的硬件,允许一条指令产生多个可以并行执行的操作,这种方式称为单指令、多数据,即sIMD并行。
        ```
        - 计算机系统中抽象的重要性
        ```
            抽象的使用是计算机科学中最为重要的概念之一。例如,为一组函数规定一个简单的应用程序接日(API)就是一个很好的编程习惯,
            程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言提供不同形式和等级的抽象支持,
            例如Java类的声明和C语言的函数原型。

            在学习操作系统时,我们介绍了三个抽象:文件是对Ⅰ/o设备的拍象,虚拟内存是对程序存储器的抽象,
            而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象:
            虚拟机,它提供对整个计算机的抽象,包括操作系统、处理器和程序。
        ```
    ###### 小结
    ```
        计算机系统是由硬件和系统软件组成的,它们共同协作以运行应用程序。
        计算机内部的信息被表示为一组组的位,它们依据上下文有不同的解释方式。
        程序被其他程序翻译成不同的形式,开始时是ASCⅡ文本,然后被编译器和链接器翻译成二进制可执行文件。

        处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、 I/o设备和CPU寄存器之间复制数据,
        所以将系统中的存储设备划分成层次结构一CPU寄存器在顶部,接着是多层的硬件高速缓存存储器、 DRAM主存和磁盘存储器。
        在层次模型中,位于更高层的存储设备比低层的存储设备要更快,单位比特造价也更高。
        层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。
        通过理解和运用这种存储层次结构的知识,程序员可以优化C程序的性能。

        操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象:
            1)文件是对Ⅰ/o设备的抽象;
            2)虚拟内存是对主存和磁盘的抽象;
            3)进程是处理器、主存和Ⅰ/o设备的抽象。
        最后,网络提供了计算机系统之间通信的手段。从特殊系统的角度来看,网络就是一种Ⅰ/o设备。
    ```
---
### 第一部分 程序结构和执行
```
    我们对计算机系统的探索是从学习计算机本身开始的,它由处理器和存储器子系统纽成。
    在核心部分,我们需要方法来表示基本数据类型,比如整数和实数运算的近似值。
    然后,我们考虑机器级指令如何操作这样的数据,以及编译器又如何将c程序翻译成这样的指令。
    接下来,研究几种实现处理器的方法,帮助我们更好地了解硬件资源如何被用来执行指令。
    一旦理解了编译器和机器级代码,我们就能了解如何通过编写C程序以及编译它们来最大化程序的性能。
    本部分以存储器子系统的设计作为结束,这是现代计算机系统最复杂的部分之一。本书的这一部分将领着你深入了解如何表示和执行应用程序。
    你将学会一些技巧,来帮助你写出安全、可靠且充分利用计算资源的程序。
```
* 第二章 信息的表示和处理
    1. 信息存储
        - 概述
        ```
            大多数计算机使用8位的块,或者字节(byte),作为最小的可寻址的内存单位,而不是访问内存中单独的位。
            机器级程序将内存视为一个非常大的字节数组,称为虚拟内存(virtualmemory)。
            内存的每个字节都由一个唯一的数字来标识,称为它的地址(address),
            所有可能地址的集合就称为虚拟地址空间(virtualaddressspace)。
            顾名思义,这个虚拟地址空间只是一个展现给机器级程序的概念性映像。
        ```
        - 十六进制表示法
        ```
            在C语言中,以Ox或OX开头的数字常量被认为是十六进制的值。字
        ```
        - 字数据大小
        ```
            每台计算机都有一个字长(wordsize),指明指针数据的标称大小(nominalsize)。
            因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。
            32位字长系统,对应虚拟内存一般为4GB,而64位系统则可达到16GB

            程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感.

            随着64位机器的日益普及,在将这些程序移植到新机器上时,许多隐藏的对字长的依赖性就会显现出来,成为错误。
            比如,许多程序员假设一个声明为int类型的程序对象能被用来存储一个指针。这在大多数32位的机器上能正常工作,但是在一台64位的机器上却会导致问题。
        ```
        - 寻址和字节顺序
        ```
            对于跨越多字节的程序对象,我们必须建立两个规则:这个对象的地址是什么,以及在内存中如何排列这些字节。
            在几乎所有的机器上,多字节对象都被存储为连续的字节序列,对象的地址为所使用字节中最小的地址。

            对于大多数应用程序员来说,其机器所使用的字节顺序是完全不可见的。无论为哪种类型的机器所编译的程序都会得到同样的结果。
            不过有时候,字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时,
            一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时,接收程序会发现,字里的字节成了反序的。
            为了避免这类问题,网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则,以确保发送方机器将它的内部表示转换成网络标准,
            而接收方机器则将网络标准转换为它的内部表示。
        ```
        - 表示字符串
        ```
            与字节顺序和字大小规则无关。因而,文本数据比二进制数据具有更强的平台独立性。
        ```
        - 表示代码
        ```
            我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。
            即使是完全一样的进程,运行在不同的操作系统上也会有不同的编码规则,因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

            计算机系统的一个基本概念就是,从机器的角度来看,程序仅仅只是字节序列。机器没有关于原始源程序的任何信息,除了可能有些用来帮助调试的辅助表以外。
            在第3章学习机器级编程时,我们将更清楚地看到这一点.
        ```
    2. 整数表示
        - 概述
        ```
            在本节中,我们描述用位来编码整数的两种不同的方式:一种只能表示非负数,而另一种能够表示负数、零和正数。
            后面我们将会看到它们在数学属性和机器级实现方面密切相关。
            我们还会研究扩展或者收缩一个已编码整数以适应不同长度表示的效果。
        ```
        - 整型数据类型
        ```
            C语言支持多种整型数据类型--表示有限范围的整数。

            示,为这些不同的大小分配的字节数根据程序编译为32位还是64位而有所不同。
            根据字节分配,不同的大小所能表示的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符long的。
            大多数64位机器使用8个字节的表示,比32位机器上使用的4个字节的表示的取值范围大很多。
            
            一个很值得注意的特点是取值范围不是对称的一负数的范围比整数的范围大1.当我们考虑如何表示负数的时候,会看到为什么会这样.

        ```
        - 无符号数的编码
        ```
            我们已经看到了许多无符号运算的细微特性,尤其是有符号数到无符号数的隐式转换,会导致错误或者漏洞的方式。
            避免这类错误的一种方法就是绝不使用无符号数。实际上,除了C以外很少有语言支持无符号整数。
            很明显,这些语言的设计者认为它们带来的麻烦要比益处多得多。比如,Java只支持有符号整数,并且要求以补码运算来实现。
            正常的右移运算符>>被定义为执行算术右移。特殊的运算符>>>被指定为执行逻辑右移。
            当我们想要把字仅仅看做是位的集合而没有任何数字意义时,无符号数值是非常有用的。
            例如,往一个字中放人描述各种布尔条件的标记(flag)时,就是这样。
            地址自然地就是无符号的,所以系统程序员发现无符号类型是很有帮助的。
            当实现模运算和多精度运算的数学包时,数字是由字的数组来表示的,无符号值也会非常有用.
        ```
    3. 整数运算
        - 概述
        ```
            许多刚人门的程序员非常惊奇地发现,两个正数相加会得出一个负数,而比较表达式x<y和比较表达式x-y<0会产生不同的结果。
            这些属性是由于计算机运算的有限性造成的。理解计算机运算的细微之处能够帮助程序员编写更可靠的代码.
        ```
        - 关于整数运算的最后思考
        ```
            正如我们看到的,计算机执行的“整数″运算实际上是一种模运算形式。表示数字的有限字长限制了可能的值的取值范围,结果运算可能溢出。
            我们还看到,补码表示提供了一种既能表示负数也能表示正数的灵活方法,同时使用了与执行无符号算术相同的位级实现,
            这些运算包括像加法、减法、乘法,甚至除法,无论运算数是以无符号形式还是以补码形式表示的,都有完全一样或者非常类似的位级行为。
        ```
    ###### 小结
    ```
        计算机将信息编码为位(比特),通常组织成字节序列。有不同的编码方式用来表示整数、实数和字符串。
        不同的计算机模型在编码数字和多字节数据中的字节顺序时使用不同的约定.
        C语言的设计可以包容多种不同字长和数字编码的实现0 64位字长的机器逐渐普及,并正在取代统治市场长达30多年的32位机器。
        由于64位机器也可以运行为32位机器编译的程序,我们的重点就放在区分32位和64位程序,而不是机器本身. 
        64位程序的优势是可以突破32位程序具有的4GB地址限制。

        由于编码的长度有限,与传统整数和实数运算相比,计算机运算具有非常不同的属性。
        当超出表示范围时,有限长度能够引起数值溢出。当浮点数非常接近于0.0,从而转换成零时,也会下溢。

        必须非常小心地使用浮点运算,因为浮点运算只有有限的范围和精度,而且并不遵守普遍的算术属性,比如结合性。
    ```

* 第二章 程序的机器级表示

